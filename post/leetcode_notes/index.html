<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>WIP: 刷题时永远记不住的东西 - 一个朴素无华的博客</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="Chuan Ma"><meta name=description content="刷题时不可能刷题的，这辈子都不可能刷题的。 学校里个个都是人才，说话也好听，我超喜欢在里面的。 数组 求数组中最大的前两个数以及其对应的下标 只需要"><meta name=keywords content="Hugo,theme,jane"><meta name=generator content="Hugo 0.117.0"><link rel=canonical href=http://localhost:1313/post/leetcode_notes/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.d8d87b982993a745e5e7b6a6cbf257be8c3e82aab5e485f0908ad7e6c3501ab2.css integrity="sha256-2Nh7mCmTp0Xl57amy/JXvow+gqq15IXwkIrX5sNQGrI=" media=screen crossorigin=anonymous><meta property="og:title" content="WIP: 刷题时永远记不住的东西"><meta property="og:description" content="刷题时不可能刷题的，这辈子都不可能刷题的。 学校里个个都是人才，说话也好听，我超喜欢在里面的。 数组 求数组中最大的前两个数以及其对应的下标 只需要"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/post/leetcode_notes/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-08-15T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-21T21:02:00+08:00"><meta itemprop=name content="WIP: 刷题时永远记不住的东西"><meta itemprop=description content="刷题时不可能刷题的，这辈子都不可能刷题的。 学校里个个都是人才，说话也好听，我超喜欢在里面的。 数组 求数组中最大的前两个数以及其对应的下标 只需要"><meta itemprop=datePublished content="2023-08-15T00:00:00+00:00"><meta itemprop=dateModified content="2023-08-21T21:02:00+08:00"><meta itemprop=wordCount content="8140"><meta itemprop=keywords content="算法,[, 数据结构],[, 刷题],"><meta name=twitter:card content="summary"><meta name=twitter:title content="WIP: 刷题时永远记不住的东西"><meta name=twitter:description content="刷题时不可能刷题的，这辈子都不可能刷题的。 学校里个个都是人才，说话也好听，我超喜欢在里面的。 数组 求数组中最大的前两个数以及其对应的下标 只需要"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=back-to-top></div><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Simonkorl</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=http://localhost:1313/>主页</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://localhost:1313/>归档</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://localhost:1313/>标签</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://localhost:1313/>分类</a></li><li class=mobile-menu-item><a class=menu-item-link href=http://localhost:1313/about/>About</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://gohugo.io rel=noopener target=_blank>外部链接
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg></i></a></li><li class=mobile-menu-item><div class="mobile-menu-parent mobile-menu-item-lang"><span class=mobile-submenu-open></span>
<a href=#><i class=iconfont><svg height="16" width="16" viewBox="0 0 128 128"><path d="m64.719501 1.4279814c-34.694029.0-62.8192028 28.1251726-62.8192028 62.8192016.0 34.694036 28.1251738 62.819207 62.8192028 62.819207 4.245691.0 8.392744-.42239 12.402214-1.2253-1.616124-.77296-1.792473-6.57213-.194346-9.87848 1.779059-3.68082 7.361625-13.00555 1.840404-16.134231-5.521221-3.12869-3.98755-4.53968-7.361625-8.15914-3.374083-3.61947-1.994181-4.16357-2.208492-5.09179-.736158-3.19004 3.251385-7.975096 3.435429-8.465866.184043-.490781.184043-2.331182.122689-2.883308-.06131-.552125-2.515051-2.024446-3.12852-2.085791-.613469-.06133-.920209.98154-1.77906 1.042896-.858856.06133-4.601018-2.269838-5.39853-2.883308-.797504-.61346-1.165591-2.085792-2.269828-3.190033-1.104247-1.104252-1.226945-.24539-2.944651-.920206-1.717714-.674812-7.238935-2.69926-11.471867-4.416975-4.23294-1.717714-4.601019-4.125615-4.662365-5.827954-.06131-1.702333-2.57657-4.171587-3.756227-5.950646-1.179335-1.77906-1.396914-4.232932-1.826339-3.680809-.429425.552114 2.208484 6.993538 1.77906 7.177582-.429425.184043-1.349635-1.77906-2.576572-3.374083-1.226936-1.595016 1.28829-.736159-2.637915-8.465864-3.926198-7.729705 1.226944-11.671284 1.472324-15.704806.24539-4.033514 3.312738 1.472325 1.717715-1.104238-1.595016-2.576571.122697-7.975094-1.104246-9.938197-1.226936-1.963102-8.220475 2.208492-8.220475 2.208492.184036-1.901758 6.134682-5.153142 10.428966-8.1591366 4.294277-3.005996 6.91682-.674813 10.367621.4294236 3.450803 1.104246 3.680817.736167 2.515226-.368079-1.165591-1.1042446.49077-1.6563686 3.190031-1.2269356 2.699269.429425 3.435428 3.6808086 7.545669 3.3740746 4.110242-.306735.429425.797511.981548 1.840412.552123 1.042892-.613468.920202-3.312729 2.760607-2.699262 1.840403.06131 1.840403 4.846407 5.337177 4.785055 3.496773 3.312729-2.331183 2.821952-4.907753-.490777-2.576563 3.496773-.552115 3.496773-.552115 2.944651 1.963094 2.400546.107972 4.547684.782784 2.147139.674814 7.967076 5.597286 7.967076 5.597286-7.300273 3.98755-2.699261 4.416975-1.472325 5.337178 1.226937.920202-2.515218 2.699261-2.515218 2.699261-1.53367-1.53367-1.779059.06131-2.760614.613476-.981548.552115-.06131 1.963095-.06131 1.963095-5.076415.797512-3.926198 6.13469-3.864852 7.422971.06131 1.288289-3.251385 3.251384-4.110242 5.091796-.858857 1.840405 2.208491 5.827948.613468 6.073336-1.595016.24539-3.190031-6.011991-11.778601-3.680808-2.589322.702954-8.343174 3.680808-5.275824 9.754153 3.06734 6.073336 8.15913-1.717714 9.876843-.858857 1.717714.858857-.490778 4.72371-.122691 4.785055.368079.06131 4.8464.168662 5.09179 5.398522.245388 5.229868 6.809502 4.785065 8.220482 4.907755 1.410972.12269 6.134682-3.864859 6.809502-4.048894.674815-.184034 3.374076-2.453876 9.263377.920195 5.889301 3.374089 8.895296 2.883308 10.919743 4.294285 2.02445 1.410987.61347 4.232939 2.51523 5.153134 1.90175.920217 9.50876-.306736 11.41051 2.821966 1.90176 3.1287-7.8524 18.833491-10.91974 20.551201-3.06734 1.71772-4.478321 5.64392-7.545665 8.15913-3.067349 2.51523-7.361625 5.62854-11.410522 8.03646-3.583968 2.1311-4.228845 5.949-5.825333 7.15419 28.11404-6.24545 49.13623-31.328971 49.13623-61.323497.0-34.694029-28.125171-62.8192016-62.819206-62.8192016zM79.442753 60.382331c-.858857.245389-2.637917 1.840405-6.993547-.736166-4.35563-2.576564-7.361625-2.085794-7.729705-2.515218.0.0-.368079-1.0429 1.533671-1.226937 3.905098-.378065 8.833951 3.619464 9.938196 3.680809 1.104246.06131 1.656361-1.104245 3.619464-.471631 1.963103.631953.490777 1.023755-.368079 1.269143zM58.891546 7.6853614c-.427786-.311152.354344-.669418.82058-1.288281.269103-.357613.0695-.951289.406356-1.28829.92021-.920203 5.459876-2.208485 4.572225.306734-.887321 2.515226-5.12434 2.760614-5.799161 2.269837zm10.98109 7.9750936c-1.533672-.06131-5.14381-.442837-4.478321-1.104246 2.591952-2.576563-.981548-3.312729-3.190039-3.496766-2.208485-.184043-3.128687-1.4109786-2.02444-1.5336776 1.104237-.12269 5.521213.06139 6.257379.6748206.736158.613469 4.723709 2.208485 4.969099 3.374076.24538 1.16559.0 2.147138-1.533678 2.085793zM83.184914 15.23103c-1.226943.981547-7.400887-3.521968-8.588569-4.539674-5.153134-4.4169746-7.913742-2.9446486-8.995903-3.6808086-1.082485-.736166-.696897-1.717713.959464-3.190039 1.656369-1.472325 6.318732.490778 9.017994.797512s5.827955 2.392527 5.889301 4.871925c.06131 2.4792256 2.944649 4.7595296 1.717713 5.7410846z"/></svg></i>语言</a></div><ul class=mobile-submenu-list><li><a href=http://localhost:1313/en/>English</a></li><li><a href=http://localhost:1313/><strong>中文</strong></a></li></ul></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Simonkorl</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=http://localhost:1313/>主页</a></li><li class=menu-item><a class=menu-item-link href=http://localhost:1313/>归档</a></li><li class=menu-item><a class=menu-item-link href=http://localhost:1313/>标签</a></li><li class=menu-item><a class=menu-item-link href=http://localhost:1313/>分类</a></li><li class=menu-item><a class=menu-item-link href=http://localhost:1313/about/>About</a></li><li class=menu-item><a class=menu-item-link href=https://gohugo.io rel=noopener target=_blank>外部链接
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6 21.568 21.632 54.144 54.208 54.144 54.208C534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92.0.0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"/><path d="M841.152 457.152c-30.528.0-54.784 24.512-54.784 54.656V786.56H237.696V237.696h206.016c6.656.0 10.752.0 13.248.0 30.72.0 55.04-24.512 55.04-54.848C512 152.32 487.36 128 456.96 128H183.04C153.216 128 128 152.576 128 182.848c0 3.136.256 6.272.768 9.28C128.256 195.136 128 198.272 128 201.408v639.488c0 .064.0.192.0.256.0.128.0.192.0.32.0 30.528 24.512 54.784 54.784 54.784H829.76c6.592.0 9.728.0 11.712.0 28.736.0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344v-20.352V561.408v-49.28C896 481.792 871.424 457.152 841.152 457.152z"/></svg></i></a></li><li class=menu-item><a class="menu-item-link menu-parent menu-item-lang" href=#><i class=iconfont><svg height="16" width="16" viewBox="0 0 128 128"><path d="m64.719501 1.4279814c-34.694029.0-62.8192028 28.1251726-62.8192028 62.8192016.0 34.694036 28.1251738 62.819207 62.8192028 62.819207 4.245691.0 8.392744-.42239 12.402214-1.2253-1.616124-.77296-1.792473-6.57213-.194346-9.87848 1.779059-3.68082 7.361625-13.00555 1.840404-16.134231-5.521221-3.12869-3.98755-4.53968-7.361625-8.15914-3.374083-3.61947-1.994181-4.16357-2.208492-5.09179-.736158-3.19004 3.251385-7.975096 3.435429-8.465866.184043-.490781.184043-2.331182.122689-2.883308-.06131-.552125-2.515051-2.024446-3.12852-2.085791-.613469-.06133-.920209.98154-1.77906 1.042896-.858856.06133-4.601018-2.269838-5.39853-2.883308-.797504-.61346-1.165591-2.085792-2.269828-3.190033-1.104247-1.104252-1.226945-.24539-2.944651-.920206-1.717714-.674812-7.238935-2.69926-11.471867-4.416975-4.23294-1.717714-4.601019-4.125615-4.662365-5.827954-.06131-1.702333-2.57657-4.171587-3.756227-5.950646-1.179335-1.77906-1.396914-4.232932-1.826339-3.680809-.429425.552114 2.208484 6.993538 1.77906 7.177582-.429425.184043-1.349635-1.77906-2.576572-3.374083-1.226936-1.595016 1.28829-.736159-2.637915-8.465864-3.926198-7.729705 1.226944-11.671284 1.472324-15.704806.24539-4.033514 3.312738 1.472325 1.717715-1.104238-1.595016-2.576571.122697-7.975094-1.104246-9.938197-1.226936-1.963102-8.220475 2.208492-8.220475 2.208492.184036-1.901758 6.134682-5.153142 10.428966-8.1591366 4.294277-3.005996 6.91682-.674813 10.367621.4294236 3.450803 1.104246 3.680817.736167 2.515226-.368079-1.165591-1.1042446.49077-1.6563686 3.190031-1.2269356 2.699269.429425 3.435428 3.6808086 7.545669 3.3740746 4.110242-.306735.429425.797511.981548 1.840412.552123 1.042892-.613468.920202-3.312729 2.760607-2.699262 1.840403.06131 1.840403 4.846407 5.337177 4.785055 3.496773 3.312729-2.331183 2.821952-4.907753-.490777-2.576563 3.496773-.552115 3.496773-.552115 2.944651 1.963094 2.400546.107972 4.547684.782784 2.147139.674814 7.967076 5.597286 7.967076 5.597286-7.300273 3.98755-2.699261 4.416975-1.472325 5.337178 1.226937.920202-2.515218 2.699261-2.515218 2.699261-1.53367-1.53367-1.779059.06131-2.760614.613476-.981548.552115-.06131 1.963095-.06131 1.963095-5.076415.797512-3.926198 6.13469-3.864852 7.422971.06131 1.288289-3.251385 3.251384-4.110242 5.091796-.858857 1.840405 2.208491 5.827948.613468 6.073336-1.595016.24539-3.190031-6.011991-11.778601-3.680808-2.589322.702954-8.343174 3.680808-5.275824 9.754153 3.06734 6.073336 8.15913-1.717714 9.876843-.858857 1.717714.858857-.490778 4.72371-.122691 4.785055.368079.06131 4.8464.168662 5.09179 5.398522.245388 5.229868 6.809502 4.785065 8.220482 4.907755 1.410972.12269 6.134682-3.864859 6.809502-4.048894.674815-.184034 3.374076-2.453876 9.263377.920195 5.889301 3.374089 8.895296 2.883308 10.919743 4.294285 2.02445 1.410987.61347 4.232939 2.51523 5.153134 1.90175.920217 9.50876-.306736 11.41051 2.821966 1.90176 3.1287-7.8524 18.833491-10.91974 20.551201-3.06734 1.71772-4.478321 5.64392-7.545665 8.15913-3.067349 2.51523-7.361625 5.62854-11.410522 8.03646-3.583968 2.1311-4.228845 5.949-5.825333 7.15419 28.11404-6.24545 49.13623-31.328971 49.13623-61.323497.0-34.694029-28.125171-62.8192016-62.819206-62.8192016zM79.442753 60.382331c-.858857.245389-2.637917 1.840405-6.993547-.736166-4.35563-2.576564-7.361625-2.085794-7.729705-2.515218.0.0-.368079-1.0429 1.533671-1.226937 3.905098-.378065 8.833951 3.619464 9.938196 3.680809 1.104246.06131 1.656361-1.104245 3.619464-.471631 1.963103.631953.490777 1.023755-.368079 1.269143zM58.891546 7.6853614c-.427786-.311152.354344-.669418.82058-1.288281.269103-.357613.0695-.951289.406356-1.28829.92021-.920203 5.459876-2.208485 4.572225.306734-.887321 2.515226-5.12434 2.760614-5.799161 2.269837zm10.98109 7.9750936c-1.533672-.06131-5.14381-.442837-4.478321-1.104246 2.591952-2.576563-.981548-3.312729-3.190039-3.496766-2.208485-.184043-3.128687-1.4109786-2.02444-1.5336776 1.104237-.12269 5.521213.06139 6.257379.6748206.736158.613469 4.723709 2.208485 4.969099 3.374076.24538 1.16559.0 2.147138-1.533678 2.085793zM83.184914 15.23103c-1.226943.981547-7.400887-3.521968-8.588569-4.539674-5.153134-4.4169746-7.913742-2.9446486-8.995903-3.6808086-1.082485-.736166-.696897-1.717713.959464-3.190039 1.656369-1.472325 6.318732.490778 9.017994.797512s5.827955 2.392527 5.889301 4.871925c.06131 2.4792256 2.944649 4.7595296 1.717713 5.7410846z"/></svg></i>中文</a><ul class=submenu><li class=submenu-item><a href=http://localhost:1313/en/>English</a></li></ul></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight wallpaper"><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>WIP: 刷题时永远记不住的东西</h1><div class=post-meta><div class=post-meta-author>by
<a href=/about><span class=post-meta-author-name>Chuan Ma</span></a></div><div class=post-meta-time><time datetime=2023-08-15>2023-08-15</time></div><div class=post-meta-lastmod>(上次更新:
2023-08-21)</div><div class=post-meta__right></div></div></header><div class=post-content><blockquote><p>刷题时不可能刷题的，这辈子都不可能刷题的。</p><p>学校里个个都是人才，说话也好听，我超喜欢在里面的。</p></blockquote><h2 id=数组>数组</h2><h3 id=求数组中最大的前两个数以及其对应的下标>求数组中最大的前两个数以及其对应的下标</h3><p>只需要 4 个变量即可做到</p><h2 id=二分搜索>二分搜索</h2><h3 id=基础算法>基础算法</h3><p>一个最简单的实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>search</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, right <span style=color:#f92672>=</span> nums.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(left <span style=color:#f92672>&lt;=</span> right){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> left;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> nums[mid];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (num <span style=color:#f92672>==</span> target) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> mid;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (num <span style=color:#f92672>&gt;</span> target) {
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个是 leetcode 的样例代码，我更喜欢左闭右开的写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// [l, r)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果存在则返回下标
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果不存在则返回 -1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>bsearch</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> a, <span style=color:#66d9ef>int</span> num) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, r <span style=color:#f92672>=</span> a.size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(l <span style=color:#f92672>&lt;</span> r) {
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(a[mid] <span style=color:#f92672>&gt;</span> num) {
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> mid;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(a[mid] <span style=color:#f92672>&lt;</span> num) {
</span></span><span style=display:flex><span>            l <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(a[mid] <span style=color:#f92672>==</span> num) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> mid;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过左闭右开的写法很容易写出错误出来，还是老老实实按照样例程序记忆吧。</p><h3 id=若干特例>若干特例</h3><h4 id=不超过-不小于>不超过、不小于</h4><p>有两个非常经典的问题：</p><ol><li>找到有序数组中不超过特定数的最大数</li><li>找到有序数组中不小于特定数的最小数</li></ol><p>这两个问题使用样例代码非常简单</p><p>当 search 函数返回 -1 的时候，它的 left 和 right 一定在搜索数的两端，left 在比搜索数大的一端，right 在比搜索数小的一端。这个特性不会因为数组中的重复元素而发生变化。但是如果使用左闭右开的方法的话，就一定会出现问题（所以一定要背标准答案啊！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>[1, 4, 4, ]
</span></span><span style=display:flex><span>bsearch end with: l 1, r 1
</span></span><span style=display:flex><span>bsearch: find nums 2, -1
</span></span><span style=display:flex><span>search end with: left 1, right 0
</span></span><span style=display:flex><span>search: find nums 2, -1
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>[1, 1, 4, ]
</span></span><span style=display:flex><span>bsearch end with: l 2, r 2
</span></span><span style=display:flex><span>bsearch: find nums 2, -1
</span></span><span style=display:flex><span>search end with: left 2, right 1
</span></span><span style=display:flex><span>search: find nums 2, -1
</span></span></code></pre></div><p>那么上面的两个问题就转化成了：</p><ol><li>如果可以找到特定数，那么直接返回它就可以</li><li>如果没有找到特定数，那么如果需要不大于它的值，则使用 right 对应的数；如果需要不小于它的值，则使用 left 对应的数</li></ol><h4 id=返回特定数最左或者最右的下标>返回特定数最左或者最右的下标</h4><p>假如说一个数组中有大量重复的元素，那么问题可能会要求你返回这个元素靠近较小数字的下标，或者靠近较大数字的下标。</p><p>样例的 search 也无法做到这一点，因为它会在搜索到 target 的时候立刻停止。</p><p>我通常的做法是，先搜索到那个特定数，然后直接向左或者向右搜索，直到尽头。一般来说效率不是特别高。</p><p>一个奇妙的做法是：对于整数题目可以把二分搜索改为 double 类型，然后搜索这个数 +- 0.5。应该可以解决问题。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> double_search(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> a, <span style=color:#66d9ef>double</span> target) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, r <span style=color:#f92672>=</span> a.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(l <span style=color:#f92672>&lt;=</span> r) {
</span></span><span style=display:flex><span>        mid <span style=color:#f92672>=</span> (l <span style=color:#f92672>+</span> r) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(a[mid] <span style=color:#f92672>&gt;</span> target) {
</span></span><span style=display:flex><span>            r <span style=color:#f92672>=</span> mid <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span>(a[mid] <span style=color:#f92672>&lt;</span> target) {
</span></span><span style=display:flex><span>            l <span style=color:#f92672>=</span> mid <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>make_pair(l, r);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>make_pair(l, r);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>[1, 1, 2, 2, 2, 4, ]
</span></span><span style=display:flex><span>bsearch: find nums 2, 3
</span></span><span style=display:flex><span>search: find nums 2, 2
</span></span><span style=display:flex><span>double search: find nums 2.0, left 5, right 4
</span></span><span style=display:flex><span>double search: find nums 1.5, left 2, right 1
</span></span></code></pre></div><h2 id=快排>快排</h2><p>总是背不下来的快排。</p><p>我已经写了一篇快排的笔记了，现在就在这里也记录一下吧。</p><p>一个最简单的快排算法真的不需要多少代码。需要记忆的内容也只有几个，我们跟着代码来一起记忆。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 1. [l, r] 记住我们的代码是左闭右闭的区间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>qsort</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> a, <span style=color:#66d9ef>int</span> l, <span style=color:#66d9ef>int</span> r) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(l <span style=color:#f92672>&gt;=</span> r) <span style=color:#66d9ef>return</span>; <span style=color:#75715e>// 2. 边界条件一定要判断
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> a[l], ll <span style=color:#f92672>=</span> l, rr <span style=color:#f92672>=</span> r; <span style=color:#75715e>// 3. pivot 如果想写的简单一点就最左边这个数就可以，不过记住是 a[l] 不是 a[0]!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(ll <span style=color:#f92672>&lt;</span> rr) { <span style=color:#75715e>// 4. 这个循环条件必不可少，决定了能否找到 pivot 真正的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 5. while 循环中的 ll &lt; rr 作为先制条件不能删除！这可以保证 ll 永远不会超过 rr，使得 swap 可以放心进行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 6. rr-- 的 while *必须* 在 ll++ 的循环之前！否则对于像是 [1, 2, 2, 2, 2] 的数组，ll 与 rr 不能正确地找到自己的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// （也就是一个元素本身就是最小的数，我们必须保证两个指针在最左侧相遇，所以为了防止这种情况，ll 必须晚于 rr 移动）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span>(ll <span style=color:#f92672>&lt;</span> rr <span style=color:#f92672>&amp;&amp;</span> a[rr] <span style=color:#f92672>&gt;=</span> pivot) rr<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(ll <span style=color:#f92672>&lt;</span> rr <span style=color:#f92672>&amp;&amp;</span> a[ll] <span style=color:#f92672>&lt;=</span> pivot) ll<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        swap(a[ll], a[rr]); <span style=color:#75715e>// 7. swap ，不难理解
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    swap(a[l], a[ll]); <span style=color:#75715e>// 8. ll 与 rr 必然都在 pivot 该在的地方，这时候交换 pivot(a[l]) 与 ll 的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    qsort(a, l, ll <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 9. 再做两次 qsort 进行分治，ll 位置已经不需要再进行排序了，所以 ll - 1, 与 ll + 1 就很合理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    qsort(a, ll <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, r);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最关键的几个：</p><ol><li>左闭右闭</li><li>pivot = a[l]</li><li>while(ll &lt; rr)</li><li>先 rr&ndash; 再 ll++</li><li>里面 swap ll, rr，外面 swap a[l], a[ll]</li><li>分治</li></ol><h2 id=字符串>字符串</h2><p>字符串考察的内容非常综合，几乎所有的考题都可以从字符串中出出来。其中最基础的是字符串的输入输出，这是 ACM 题目的最基本的一步；其次是数组，因为字符串一般都是用数组储存的；再然后是动归、字符串处理这些更加复杂的算法。在这里我们没办法把所有字符串处理的内容都记录下来，只能就其中比较基础和简单的问题进行一下讨论。</p><h3 id=字符串基础小知识>字符串基础小知识</h3><h4 id=字符串的元素顺序>字符串的元素顺序</h4><ul><li><p>问题：对于字符串 &ldquo;123456&rdquo; 而言，哪个数字的下标是 0 ？</p><p>答案：1</p><p>这个问题不能想，必须一下子回答出来。无论是什么编程语言，都是左边的字符下标小，右边的字符下标大。如同写字是从左往右写的。</p></li></ul><h4 id=反转字符串>反转字符串</h4><p><a href=https://blog.csdn.net/u014339447/article/details/109232871>https://blog.csdn.net/u014339447/article/details/109232871</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>string <span style=color:#a6e22e>reverse</span>(string s) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> string(s.rbegin(), s.rend());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=c-c-plus-plus-的输出输出与字符串>C/C++ 的输出输出与字符串</h3><p>众所周知，C/C++ 的输入输出是出了名的费劲，不过我们必须牢记这个过程。</p><h4 id=基础输入输出>基础输入输出</h4><p>16 进制的读写</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%X&#34;</span>, <span style=color:#f92672>&amp;</span>x); <span style=color:#75715e>// %x 也可以
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>printf(<span style=color:#e6db74>&#34;%#x&#34;</span>, x); <span style=color:#75715e>// 这样打印会有 0x 前缀
</span></span></span></code></pre></div><ul><li>%#x：输出带有 0x 前缀的十六进制数。</li></ul><p>浮点数的输入输出</p><p>scanf 只能读入 float !</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>float</span> f;
</span></span><span style=display:flex><span>scanf(<span style=color:#e6db74>&#34;%f&#34;</span>, <span style=color:#f92672>&amp;</span>f); <span style=color:#75715e>// %e, %E, %g 也可以读入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>printf(<span style=color:#e6db74>&#34;%0.2f&#34;</span>, <span style=color:#ae81ff>0.114514</span>);
</span></span><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;%+E&#34;</span>, <span style=color:#ae81ff>103801801.0</span>);
</span></span><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;%+lf</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>103801801</span>); <span style=color:#75715e>// 不要这样！会输出 0.0000 。数据类型一定要正确！
</span></span></span></code></pre></div><ul><li>%-10s：左对齐并占用宽度为 10 的字符串；</li><li>%+4d：右对齐并占用宽度为 4，强制显示正负号的整数；</li><li>%5.2f：右对齐并占用宽度为 5，保留两位小数的浮点数；</li></ul><p>不知道长度的输入输出</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> ans[<span style=color:#ae81ff>10</span>][<span style=color:#ae81ff>100</span>]; <span style=color:#75715e>// 10 个长度为 100 的字符数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>while</span>(scanf(<span style=color:#e6db74>&#34;%s&#34;</span>, ans[num]) <span style=color:#f92672>!=</span> EOF) {
</span></span><span style=display:flex><span>    num<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>num <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>string s[<span style=color:#ae81ff>10</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(cin <span style=color:#f92672>&gt;&gt;</span> s[num]) {
</span></span><span style=display:flex><span>    num<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>C++ split</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> input[<span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;abc,d&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>      如果找到了分隔符的话，strtok 会在分隔符前加上一个 \0
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> strtok(input, <span style=color:#e6db74>&#34;,&#34;</span>); <span style=color:#75715e>// 这个函数会破坏原有的字符串，如果需要源字符串则你需要复制一份
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(p) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, p);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>     之后调用 strtok 需要使用 NULL 作为第一个参数。如果可以分割，则返回字符串指针。如果不行则返回 NULL
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> strtok(NULL, <span style=color:#e6db74>&#34;,&#34;</span>)<span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=最长公共子序列-简单的动归>最长公共子序列：简单的动归</h4><p>一个朴素的 DP 题目</p><h4 id=字符串匹配-超难动归-kmp>TODO 字符串匹配：超难动归 KMP</h4><p>暂时我解释不清楚这个算法，之后再来补上</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>buildNext</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>P) {
</span></span><span style=display:flex><span>    size_t m <span style=color:#f92672>=</span> strlen(P), j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>N <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>[m];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> t <span style=color:#f92672>=</span> N[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(j <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        (t <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> P[j] <span style=color:#f92672>==</span> P[t]) <span style=color:#f92672>?</span> N[<span style=color:#f92672>++</span>j] <span style=color:#f92672>=</span> <span style=color:#f92672>++</span>t :  t <span style=color:#f92672>=</span> N[t];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> N;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>match</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>P, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>T) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> buildNext(P);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> strlen(T), i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> strlen(P), j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(j <span style=color:#f92672>&lt;</span> m <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> T[i] <span style=color:#f92672>==</span> P[j]) {
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>; j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            j <span style=color:#f92672>=</span> next[j];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span>[] next;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> i <span style=color:#f92672>-</span> j;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=滑动窗口>滑动窗口</h2><p>滑动窗口是一种可以明显降低时间复杂度的方案。滑动窗口可以使得每一次处理的时间和空间都局限在一个窗口内部，这使得一个 O(N) 的问题可以变成每一次 O(k) 处理，一共处理 O(N) 次。滑动窗口问题最困难的部分有两个：一个是每个窗口应该如何处理，二是每次改变窗口的时候应该如何处理。</p><p>滑动窗口问题需要首先解决一个问题：应该怎么维护一个窗口？</p><p>一般来说一个窗口都是从下标 i 到下标 i + k 的一段区域所设计的元素，我们一般的操作都是要把这个窗口的元素放到某个数据结构当中，然后维护这个窗口。那么我们至少涉及三个操作：向数据结构中增加元素、在数据结构中搜索要删除的元素、删除这个元素。一般来说我们希望时间复杂度不要超过 log(n)，那么我们稍微分析一下这其中的时间开销。</p><p>添加数据和删除数据一般不需要大量的时间开销。哪怕使用开销最大的数组作为数据结构，那么我们通常总是可以使用两个指针来表明窗口，而不需要手动维护一个完整的数组（毕竟数组主要是用来储存连续的数据的，如果需要维护特征的话我们肯定需要使用其他的数据结构）</p><p>那么就可以发现，绝大部分需要优化的东西都留在了搜索要删除的元素。如果可以把这个工作压到 O(1) ，一般程序就是 O(n) 复杂度了；哪怕不得不是 O(logn) 的时间也是整体 O(nlogn) 的时间。</p><p>那么之后分析滑动窗口的问题就非常简单了，我们只需要针对窗口的变化，熟悉我们需要使用的多种不同的数据结构以及维护变化的方法就好了。我们结合题目来进行分析。</p><h3 id=滑动窗口最大值-堆-单调队列>滑动窗口最大值（堆，单调队列）</h3><p>这是一道非常经典的题目，也是滑动窗口中最朴素的复合题目。</p><p>滑动窗口的第一个可用的工具就是堆，因为它总是能维护一个最大值或者最小值。</p><h4 id=堆>堆</h4><ul><li><p>priority_queue 的特性</p><p>我们先来总结一些奇妙的 priority_queue 特性：</p><ol><li>priority_queue 对于 Pair 有自己默认的排序方法，先后比较 first ，而且优先使用 &lt; 比较符号。所以使用 pair&lt;int, int> 你可以得到一个大根堆：首先是按照第一个元素从大到小排序，然后是按照第二个元素从大到小排序</li><li>priority_queue.emplace 函数可以就地使用构造函数插入一个新的量。</li><li>priority_queue 并不是一个 set，它里面所有的元素是可以重复的！不过这些重复的元素并没有任何提示说明他们什么时候进入的队列</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pq1;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>    pq1.push(i <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(pq1.size()) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d, &#34;</span>, pq1.top());
</span></span><span style=display:flex><span>    pq1.pop();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 7, 7, 6, 6, 5, 5, 4, 4,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>priority_queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> pq2;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> e: {pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>{<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>}, pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>{<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>2</span>}, pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>}, pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>{<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}, pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>}}) {
</span></span><span style=display:flex><span>    pq2.push(e);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span>(pq2.size()) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;(%d, %d), &#34;</span>, pq2.top().first, pq2.top().second);
</span></span><span style=display:flex><span>    pq2.pop();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// (5, 3), (5, 2), (3, 4), (2, 5), (1, 2),
</span></span></span></code></pre></div></li></ul><ul><li><p>滑动窗口与堆：只要知道什么时候删除</p><p>堆最主要的问题就是说我们没办法只用一个元来维护窗口。因为堆中搜索元素需要 O(N) ，我们根本无法每次都遍历堆然后增减元素。所以我们的思路有两个：</p><ol><li>加快堆搜索元素的效率，比如说把堆中的每个元素和一个搜索结构对应起来（比如说一个 map）</li><li>想办法保证需要删除的元素一定在堆顶（毕竟堆中的其他元素实际上是有一定顺序的，并不需要担心加入数据的时候出现太多问题）</li></ol><p>第一个思路比较朴素，我们可以维护一个 unordered_map 来解决这个问题。记录窗口中所有的元素，并且使用 unordered_map 来维护窗口中元素的个数。然后让 priority_queue 记录 map 中的元素指针就可以做到。但是这也太复杂了，完全没有那个必要。</p><p>第二个思路直接看起来有些困难，我们不妨反过来思考：我们不去考虑找到所有需要删除的元素，只去考虑堆顶的元素什么时候需要被删除即可。也就是说，我们不需要维护堆中的每一个元素，保证他们都在窗口中，我们只要保证我们的堆顶元素在窗口中，那么我们给出的一定是正确答案。解题思路一下子就改成了：</p><ol><li>如何确认堆顶元素在窗口中：记录每个元素的下标，在插入元素的时候就可以根据窗口大小知道这个元素是否在窗口中</li><li>如何维护堆顶元素在窗口中：每次添加新元素的时候检查堆顶元素，如果不在窗口中就删去。重复此步骤，直到满足条件为止</li></ol><p>现在我们就可以利用 priority_queue 的特性，利用一个 pair 来书写这个程序了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> maxSlidingWindow(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> nums.size();
</span></span><span style=display:flex><span>        priority_queue<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> k; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            q.emplace(nums[i], i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ans <span style=color:#f92672>=</span> {q.top().first};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> k; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            q.emplace(nums[i], i);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 下面这个步骤是最关键的，删除栈顶元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> (q.top().second <span style=color:#f92672>&lt;=</span> i <span style=color:#f92672>-</span> k) {
</span></span><span style=display:flex><span>                q.pop();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ans.push_back(q.top().first);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 作者：力扣官方题解
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 链接：https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 来源：力扣（LeetCode）
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</span></span></span></code></pre></div></li></ul><h4 id=单调队列>单调队列</h4><p>单调队列是采用双向队列 deque 的一种处理滑动窗口问题的巧妙方法。它的维护数据结构的逻辑稍微有一点复杂，思路如下：
我们先准备一个双向队列，它像是传送带一样：我们需要的元素都在它的头部，我们可能需要的数据都在它的中间，我们不需要的数据根本不会进入队列。这有一点像堆，但是我们需要手动维护这个队列。（为什么偏偏要选择一个更难的方法维护？因为有些题目没办法用堆）</p><p>对于任何后来的数据而言，它们离开窗口的时间一定晚于之前的数据。如果它们相对于等待的数据而言更加符合题目要求（更优秀）的话，那么排在队尾的一系列数据就都失去了意义：新的数据到来意味着，它们无论在前一个窗口还是后一个窗口都不会被需要，所以只能被淘汰。这样我一定能保证队列中的数据要么是当前窗口最好的，要么是下一个窗口中比较好的，队列中一定不会有没有用的数据。然后需要从队首舍弃一系列过期的数据，这样就可以完成对数据的维护。</p><p>有一个不错的比喻就是，这个很像是公司招人。窗口就是一个时间段，头就是这段时间里最优秀的人，中间就是次优的人，其他不够优秀的人完全进不了队列。首先，你为了进入公司，你至少需要比公司里的比较优秀的人要好；要是有新人进来后，发现公司里有很多人还没有新人厉害，那么新人有强，干得时间又久，那么队列中那些中间的人就一定不会出头，他们也就不被需要了。然后我们需要处理的就是太老的人，我们需要把它们舍弃，因为退休时间到了。你看，就这么简单。</p><p>对于这道题来说，我们队列中维护的并不是数值，而是下标。单向队列必须要维护下标，因为除此之外我们无法得知窗口什么时候结束。简单的流程如下：</p><ol><li>对于每一个新成员，检查是否比队尾的成员优秀。持续删除队尾元素，直到队列中没有元素，或者新数据不够优秀为止。</li><li>让新成员加入</li><li>持续删除队首的超时数据</li><li>输出答案</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> maxSlidingWindow(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> nums.size();
</span></span><span style=display:flex><span>        deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> k; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty() <span style=color:#f92672>&amp;&amp;</span> nums[i] <span style=color:#f92672>&gt;=</span> nums[q.back()]) {
</span></span><span style=display:flex><span>                q.pop_back();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            q.push_back(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ans <span style=color:#f92672>=</span> {nums[q.front()]};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> k; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty() <span style=color:#f92672>&amp;&amp;</span> nums[i] <span style=color:#f92672>&gt;=</span> nums[q.back()]) {
</span></span><span style=display:flex><span>                q.pop_back();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            q.push_back(i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (q.front() <span style=color:#f92672>&lt;=</span> i <span style=color:#f92672>-</span> k) {
</span></span><span style=display:flex><span>                q.pop_front();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ans.push_back(nums[q.front()]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>作者：力扣官方题解
</span></span></span><span style=display:flex><span><span style=color:#75715e>链接：https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/
</span></span></span><span style=display:flex><span><span style=color:#75715e>来源：力扣（LeetCode）
</span></span></span><span style=display:flex><span><span style=color:#75715e>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h2 id=链表>链表</h2><h3 id=链表是否有环>链表是否有环</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 判断链表有环
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 有一个非常不错的双指针方法，在 leetcode 的同样题目下有关于链表比较详细的解析
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ListNode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    ListNode<span style=color:#f92672>*</span> next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    ListNode(<span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) {<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> v;}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>() {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;(%d)[%p]-&gt;[%p]-&gt;&#34;</span>, val, <span style=color:#66d9ef>this</span>, next);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>has_loop</span>(ListNode<span style=color:#f92672>*</span> start) {
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span>first <span style=color:#f92672>=</span> start, <span style=color:#f92672>*</span>second <span style=color:#f92672>=</span> start;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(first <span style=color:#f92672>!=</span> NULL <span style=color:#f92672>&amp;&amp;</span> second <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        second <span style=color:#f92672>=</span> second<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(second <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(second <span style=color:#f92672>==</span> first) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        second <span style=color:#f92672>=</span> second<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(second <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(second <span style=color:#f92672>==</span> first) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        first <span style=color:#f92672>=</span> first<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// char str[3];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// std::cin&gt;&gt;str;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 正确的写法：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    vector<span style=color:#f92672>&lt;</span>ListNode<span style=color:#f92672>&gt;</span> nodes(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        nodes[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            nodes[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>].next <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>nodes[i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(i <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>            nodes[i].next <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>nodes[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 错误的写法:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// vector&lt;ListNode&gt; nodes;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// for(int i = 0;i &lt; 3; ++i) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     nodes.push_back(ListNode(i));
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     if(i &gt; 0) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//         nodes[i - 1].next = &amp;nodes[i];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     if(i == 2) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//         nodes[i].next = &amp;nodes[0];
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 这个代码会因为 vector 的 push_back 而导致内存地址变动，非常危险
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 如果想把 vector 当数组用，那么最好还是先分配好大小吧。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    ListNode <span style=color:#f92672>*</span>start <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>nodes[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> has_loop(start) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=堆>堆</h2><h3 id=堆的定义>堆的定义</h3><p>以小根堆为例：对于堆的每一个节点而言，该节点均比所有自己的子节点小，但是对于其他的子节点不需要关心顺序</p><h3 id=手撸一个堆>手撸一个堆</h3><h4 id=二叉堆>二叉堆</h4><p>堆的储存：一般 vector 就足够了，我们使用线性二叉树来储存这个堆</p><p>一个结点的子节点与父节点的下标为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>  0
</span></span></span><span style=display:flex><span><span style=color:#75715e>  1 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>  3 4 5 6
</span></span></span><span style=display:flex><span><span style=color:#75715e>  7 8 9 10
</span></span></span><span style=display:flex><span><span style=color:#75715e>  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> parent <span style=color:#f92672>=</span> (i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span></code></pre></div><p>请记住：如果你要在原来的数组上就地操作的话，你必须手动维护当前堆的大小 heapSize.</p><h4 id=堆的更新-o--logn>堆的更新 O(log(N))</h4><p>堆的每一次更新一定从堆的叶节点开始，向上一直传播到根节点。这个过程一定只会执行一次，不会重复执行。</p><p>堆的更新可以分为两种：下沉与上浮</p><p>下沉是从根节点开始，从上往下逐个与儿子中更小的那个进行比较，如果不满足堆的条件就进行交换，直到满足条件为止。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>4
</span></span><span style=display:flex><span>8 10
</span></span><span style=display:flex><span>12 14 16 18
</span></span><span style=display:flex><span># pop
</span></span><span style=display:flex><span>18 &lt;-
</span></span><span style=display:flex><span>8 &lt; 10
</span></span><span style=display:flex><span>12 14 16
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>   8
</span></span><span style=display:flex><span>-&gt; 18 10
</span></span><span style=display:flex><span>   12 &lt; 14 16
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>8
</span></span><span style=display:flex><span>12 10
</span></span><span style=display:flex><span>18 14 16
</span></span></code></pre></div><p>上浮则是相反，从下往上比较，如果不满足堆的条件则交换，直到满足为止。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>4
</span></span><span style=display:flex><span>8 10
</span></span><span style=display:flex><span>12 14 16 18
</span></span><span style=display:flex><span># push(2)
</span></span><span style=display:flex><span>4
</span></span><span style=display:flex><span>8 10
</span></span><span style=display:flex><span>12 14 16 18
</span></span><span style=display:flex><span>v
</span></span><span style=display:flex><span>2 &lt;-
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>  4
</span></span><span style=display:flex><span>  8 10
</span></span><span style=display:flex><span>  v
</span></span><span style=display:flex><span>-&gt;2 14 16 18
</span></span><span style=display:flex><span>  12
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>  4
</span></span><span style=display:flex><span>  v
</span></span><span style=display:flex><span>-&gt;2 10
</span></span><span style=display:flex><span>  8 14 16 18
</span></span><span style=display:flex><span>  12
</span></span><span style=display:flex><span>---
</span></span><span style=display:flex><span>2
</span></span><span style=display:flex><span>4 10
</span></span><span style=display:flex><span>8 14 16 18
</span></span><span style=display:flex><span>12
</span></span></code></pre></div><p>其中，建堆与删除操作会使用下沉，而增加操作会使用上浮。</p><p>我们来看一个参考实现</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 例子都是大根堆
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 从 idx 位置开始进行下沉操作
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 大根堆找儿子结点中大的那个
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 小根堆找儿子结点中小的那个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sink</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> a, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> heapSize) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>, largest <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;</span> heapSize <span style=color:#f92672>&amp;&amp;</span> a[l] <span style=color:#f92672>&gt;</span> a[largest]) {
</span></span><span style=display:flex><span>            largest <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>&lt;</span> heapSize <span style=color:#f92672>&amp;&amp;</span> a[r] <span style=color:#f92672>&gt;</span> a[largest]) {
</span></span><span style=display:flex><span>            largest <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (largest <span style=color:#f92672>!=</span> i) {
</span></span><span style=display:flex><span>            swap(a[i], a[largest]);
</span></span><span style=display:flex><span>            sink(a, largest, heapSize);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>goup</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> a, <span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> parent <span style=color:#f92672>=</span> (i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(a[parent] <span style=color:#f92672>&lt;</span> a[i]) {
</span></span><span style=display:flex><span>        swap(a[parent], a[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(parent <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        goup(a, parent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我更喜欢迭代的实现方法，不过面试的时候永远是简单的越好。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sink</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> a, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> heapSize) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, r <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>, largest <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(l <span style=color:#f92672>&lt;</span> heapSize <span style=color:#f92672>||</span> r <span style=color:#f92672>&lt;</span> heapSize) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;</span> heapSize <span style=color:#f92672>&amp;&amp;</span> a[l] <span style=color:#f92672>&gt;</span> a[largest]) {
</span></span><span style=display:flex><span>                largest <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>&lt;</span> heapSize <span style=color:#f92672>&amp;&amp;</span> a[r] <span style=color:#f92672>&gt;</span> a[largest]) {
</span></span><span style=display:flex><span>                largest <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (largest <span style=color:#f92672>!=</span> i) {
</span></span><span style=display:flex><span>                swap(a[i], a[largest]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                i <span style=color:#f92672>=</span> largest;
</span></span><span style=display:flex><span>                l <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                r <span style=color:#f92672>=</span> i <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>                largest <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>goup</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> a, <span style=color:#66d9ef>int</span> i) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> parent <span style=color:#f92672>=</span> (i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(true) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(a[parent] <span style=color:#f92672>&lt;</span> a[i]) {
</span></span><span style=display:flex><span>            swap(a[parent], a[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(parent <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            i <span style=color:#f92672>=</span> parent;
</span></span><span style=display:flex><span>            parent <span style=color:#f92672>=</span> (i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=floyd-建堆法o--n>floyd 建堆法O(N)</h4><ol><li>将所有的元素一股脑放进一个 vector 中，组成一个二叉树</li><li>从最后一个 <strong>非叶节点</strong> 开始，进行“下沉”操作</li><li>逆序处理直到根节点为止。</li></ol><p>总共的复杂程度不会超过 O(N)，具体证明忘记了。</p><p>这里面最难的一步就是找到最后一个非叶节点的下标。我们不妨认为一共有 n 个数，那么最后一个非叶节点的坐标就是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>0
</span></span></span><span style=display:flex><span><span style=color:#75715e>1 2
</span></span></span><span style=display:flex><span><span style=color:#75715e>3 4* 5 6
</span></span></span><span style=display:flex><span><span style=color:#75715e>7 8 9 10
</span></span></span><span style=display:flex><span><span style=color:#75715e>n = 11-&gt;4
</span></span></span><span style=display:flex><span><span style=color:#75715e>n = 10-&gt;4
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build_heap</span>(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> a) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> a.size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> start <span style=color:#f92672>=</span> (n<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>; <span style=color:#75715e>// 实际上从 n / 2 出发也没有任何问题，不过我们还是严谨起见
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> start; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#f92672>--</span>i) {
</span></span><span style=display:flex><span>        sink(a, i, len);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=堆的操作>堆的操作</h4><p>堆有三种操作：查看堆顶元素，插入一个元素，移除一个元素</p><p>查看堆顶元素 top 只需要返回 heap[0] 即可。</p><p>插入元素是在数组的末尾插入元素，然后对该元素进行上浮操作</p><p>移除元素是将 top 元素与末尾的元素交换，缩减 heap 的大小，之后对根节点做下沉。</p><h3 id=使用标准库>使用标准库</h3><p>C++ 的堆标准库来自 &lt;priority_queue> ，可以用下面的代码调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;priority_queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> nums <span style=color:#f92672>=</span> {<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>};
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 优先级队列通常需要给三个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 第一个参数是储存数据的类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 第二个参数是储存数据的数据结构，一般使用 vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 第三个是比较函数，一般用 greater&lt;T&gt; 和 less&lt;T&gt; 就可以。其中 less&lt;T&gt; 是大根堆，greater&lt;T&gt;是小根堆
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, less<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> big_root_heap(nums.begin(), nums.end());
</span></span><span style=display:flex><span>    priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> small_root_heap(nums.begin(), nums.end());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 top 函数获得栈顶元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> small_root_heap.top() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &gt; 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 使用 pop 函数删除元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    small_root_heap.pop();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> small_root_heap.top() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &gt; 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 使用 push 增加元素
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    small_root_heap.push(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> small_root_heap.top() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// &gt; 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=第-k-个最大的数>第 k 个最大的数</h3><h2 id=迭代遍历>迭代遍历</h2><p>您还在为遍历列表是空指针而痛苦吗，您还在为数组下标越界而苦恼吗，您还在为树的遍历不会而头痛吗？来到这里，我们都会一口气解决它们。</p><h3 id=列表的两个两个走-奇偶链表>列表的两个两个走（奇偶链表）</h3><h3 id=数组的二分>数组的二分</h3><p>为了让大家不再害怕，我们就把二分可能产生的下标情况都列出来。</p><h2 id=递归>递归</h2><blockquote><p>一朵名为栈溢出的乌云在程序员的头上飘着。</p></blockquote><p>递归虽然危险很大，但是可以简化一大堆东西。千万不要因为占用栈的空间大而不去使用啊。</p><ul><li>全局状态的维护</li><li>递归当前状态的维护</li><li>递归返回值的讲究。</li><li>递归与栈的使用</li></ul><h2 id=二进制>二进制</h2><blockquote><p>就当是为了我，对它使用指数吧。</p></blockquote><p>1,2,4,8 为核心的指数应该如何使用呢？</p><h3 id=长除法的代码实现>长除法的代码实现</h3><p>长除法一般的写法都是竖过来的，因为这样比较方便用手计算：</p><p>2| 11 ^
<del>&mdash;&ndash; &ndash; 1 |
2| 5 |
+&mdash;&ndash; &ndash; 1 |
2| 2 |
+&mdash;&ndash; &ndash; 0 |
1 |
o&mdash;&mdash;&mdash;</del>
(11)10 = (1011)2</p><p>不过对于计算机来说，我们还是把它横过来写可能会更好一点：</p><pre><code> 2    2    2    2
</code></pre><p>n 11&mdash;>5&mdash;>2&mdash;>1&mdash;>0
r 1 1 0 1
&lt;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;o</p><p>可以看到，每次进行一次除 2 操作，然后查看除法过程中的余数（在计算机语言中，这个余数需要在除 2之前获得）。持续除 2 直到数字为 0 为止。</p><p>很简单对吧，那么我们就来实现最简单的整数转二进制字符串。本题最复杂的步骤实际上是反转字符串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>string <span style=color:#a6e22e>trans</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    string s;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        bit <span style=color:#f92672>=</span> n <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        n <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        s.push_back(bit);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> string(s.rbegin(), s.rend());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=二进制-1-的个数-简单>二进制 1 的个数（简单）</h3><p>可以基于长除法解决</p><h3 id=距离-n-最近的-2-的幂次-简单>距离 n 最近的 2 的幂次（简单）</h3><h3 id=基础位运算优化>基础位运算优化</h3><ul><li>对 2 的幂次取模 == 对幂次 - 1 求与<ul><li>n % 2 == n & 1</li><li>n % 8 == n & 7</li></ul></li><li>n & n - 1：长除法中的一步除法或求余</li></ul><h3 id=快速幂运算>快速幂运算</h3><p>递归</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> quickMul(<span style=color:#66d9ef>double</span> x, <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> N) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (N <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> y <span style=color:#f92672>=</span> quickMul(x, N <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> N <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> y <span style=color:#f92672>*</span> y : y <span style=color:#f92672>*</span> y <span style=color:#f92672>*</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>myPow</span>(<span style=color:#66d9ef>double</span> x, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> N <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> N <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> quickMul(x, N) <span style=color:#f92672>:</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> quickMul(x, <span style=color:#f92672>-</span>N);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>迭代</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> quickMul(<span style=color:#66d9ef>double</span> x, <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> N) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 贡献的初始值为 x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> x_contribute <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在对 N 进行二进制拆分的同时计算答案
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (N <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (N <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 如果 N 二进制表示的最低位为 1，那么需要计入贡献
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                ans <span style=color:#f92672>*=</span> x_contribute;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将贡献不断地平方
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            x_contribute <span style=color:#f92672>*=</span> x_contribute;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            N <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>myPow</span>(<span style=color:#66d9ef>double</span> x, <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> N <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> N <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> quickMul(x, N) <span style=color:#f92672>:</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> quickMul(x, <span style=color:#f92672>-</span>N);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=动态规划>动态规划</h2><blockquote><p>动态规划如天书，虐我千题仍不足。状态转移加初始，整体有向无环图。</p></blockquote><p>这个讲得实在是太好了，建议动态规划不懂的时候就去再看一遍。</p><p><a href=https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/>https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/</a></p><h3 id=最大子序列之和>最大子序列之和</h3><h3 id=最长上升子序列>最长上升子序列</h3><h3 id=下降路径最小和>下降路径最小和</h3><h2 id=前缀和>前缀和</h2><p>前缀和在处理滑动窗口、数组子序列等问题上都可以有非常不错的发挥。我们要首先记住它的基础公式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>s[i] <span style=color:#f92672>=</span> nums[i] <span style=color:#f92672>+</span> s[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span></code></pre></div><p>前缀和的基础公式非常简单，当前值就是之前值的和，而当前值就是把自己累加到之前的和上面。非常简单对不对。</p><p>前缀和的第一个特点就是其可以非常简单地转换为区间和：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// sum of [l, r]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>sum <span style=color:#f92672>=</span> s[r] <span style=color:#f92672>-</span> s[l <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span></code></pre></div><p>在一些滑动窗口的题目中需要求区间和，使用前缀和可以非常容易地完成。并且对于一些题目，甚至不需要储存所有的前缀和，而是只需要其中的两端。</p><h3 id=例-1-最大连续1的个数-iii>例 1：最大连续1的个数 III</h3><p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/?envType=list&amp;envId=62ml08g">https://leetcode.cn/problems/max-consecutive-ones-iii/?envType=list&amp;envId=62ml08g</a></p><p>这道题的标准解是一个滑动窗口与前缀和的结合。因为这样就可以便捷地计算窗口和。同时滑动窗口的好处是，每一个窗口，它的左端点和右端点基本上只有向右移动一个选项，这使得利用前缀和，我们只需要储存两个值即可：一个左端点的，一个右端点的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> longestOnes(vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> nums, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> nums.size();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 前缀和(0 的个数)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> lsum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> , rsum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> max_window <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 滑动窗口 [l, r]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> left <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 其中 left 代表下一个要删除的端点下标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; right <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>right) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 延申右侧的端点，计算前缀和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            rsum <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> nums[right];
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果左侧的窗口不满足条件，那么需要进行缩减，直到满足条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 这里不需要 left &lt; right 的条件，因为如果 left = right + 1，则说明此时为空窗口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 那么必然有 rsum - lsum == 0(rsum - lsum == 0 &lt;=&gt; left = right + 1)，因为 k 不可能为负值，所以 while 的条件永远不可能成立
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span>(rsum <span style=color:#f92672>-</span> lsum <span style=color:#f92672>&gt;</span> k) {
</span></span><span style=display:flex><span>                lsum <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> nums[left<span style=color:#f92672>++</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 当程序运行到这里的时候一定满足：
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 1. rsum - lsum 为窗口 [l, r] 的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 2. 如果 l &gt; r 那么必然有 l = r + 1 &lt;=&gt; rsum - lsum == 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 3. rsum - lsum &lt;= k
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 综上：此时的滑动窗口必然为满足条件的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            max_window <span style=color:#f92672>=</span> max(max_window, right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max_window;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>Chuan Ma</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2023-08-21</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=http://localhost:1313/tags/%E7%AE%97%E6%B3%95/>算法</a>
<a href=http://localhost:1313/tags/>[, 数据结构]</a>
<a href=http://localhost:1313/tags/>[, 刷题]</a></div><nav class=post-nav><a class=prev href=/post/c++%E9%9D%A2%E8%AF%95%E6%B7%B1%E5%9D%91/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg></i><span class="prev-text nav-default">WIP: C++ 知识深坑</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/helloworld/><span class="next-text nav-default">Hello World!</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg></i></a></nav></footer></article></div><nav class=toc id=toc><div class=toc-title>文章目录</div><div class="toc-content custom-scrollbar"><nav id=TableOfContents><ul><li><a href=#数组>数组</a><ul><li><a href=#求数组中最大的前两个数以及其对应的下标>求数组中最大的前两个数以及其对应的下标</a></li></ul></li><li><a href=#二分搜索>二分搜索</a><ul><li><a href=#基础算法>基础算法</a></li><li><a href=#若干特例>若干特例</a></li></ul></li><li><a href=#快排>快排</a></li><li><a href=#字符串>字符串</a><ul><li><a href=#字符串基础小知识>字符串基础小知识</a></li><li><a href=#c-c-plus-plus-的输出输出与字符串>C/C++ 的输出输出与字符串</a></li></ul></li><li><a href=#滑动窗口>滑动窗口</a><ul><li><a href=#滑动窗口最大值-堆-单调队列>滑动窗口最大值（堆，单调队列）</a></li></ul></li><li><a href=#链表>链表</a><ul><li><a href=#链表是否有环>链表是否有环</a></li></ul></li><li><a href=#堆>堆</a><ul><li><a href=#堆的定义>堆的定义</a></li><li><a href=#手撸一个堆>手撸一个堆</a></li><li><a href=#使用标准库>使用标准库</a></li><li><a href=#第-k-个最大的数>第 k 个最大的数</a></li></ul></li><li><a href=#迭代遍历>迭代遍历</a><ul><li><a href=#列表的两个两个走-奇偶链表>列表的两个两个走（奇偶链表）</a></li><li><a href=#数组的二分>数组的二分</a></li></ul></li><li><a href=#递归>递归</a></li><li><a href=#二进制>二进制</a><ul><li><a href=#长除法的代码实现>长除法的代码实现</a></li><li><a href=#二进制-1-的个数-简单>二进制 1 的个数（简单）</a></li><li><a href=#距离-n-最近的-2-的幂次-简单>距离 n 最近的 2 的幂次（简单）</a></li><li><a href=#基础位运算优化>基础位运算优化</a></li><li><a href=#快速幂运算>快速幂运算</a></li></ul></li><li><a href=#动态规划>动态规划</a><ul><li><a href=#最大子序列之和>最大子序列之和</a></li><li><a href=#最长上升子序列>最长上升子序列</a></li><li><a href=#下降路径最小和>下降路径最小和</a></li></ul></li><li><a href=#前缀和>前缀和</a><ul><li><a href=#例-1-最大连续1的个数-iii>例 1：最大连续1的个数 III</a></li></ul></li></ul></nav></div></nav></div></main><footer id=footer class=footer><div class=icon-links><a href=mailto:simonkorl0228@gmail.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg></a><a href=https://github.com/simonkorl rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" style viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=http://localhost:1313/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2017 -
2023
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>Chuan Ma</span></span></div></footer><div class=button__back-to-top><a href=#back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></a></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.6b2fb05cf245a92263a8c75c055bf9cfd884240dd6081ed866313142069d4c27.js integrity="sha256-ay+wXPJFqSJjqMdcBVv5z9iEJA3WCB7YZjExQgadTCc=" crossorigin=anonymous></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css integrity=sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js integrity=sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{})})</script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>