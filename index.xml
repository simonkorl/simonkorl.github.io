<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>一个朴素无华的博客</title><link>http://localhost:1313/</link><description>Recent content on 一个朴素无华的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 15 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>http://localhost:1313/about/</link><pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate><guid>http://localhost:1313/about/</guid><description>&lt;p>Hugo is a static site engine written in Go.&lt;/p>
&lt;p>It makes use of a variety of open source projects including:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/spf13/cobra">Cobra&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/viper">Viper&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/jWalterWeatherman">J Walter Weatherman&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/spf13/cast">Cast&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Learn more and contribute on &lt;a href="https://github.com/gohugoio">GitHub&lt;/a>.&lt;/p></description></item><item><title>WIP: C++ 知识深坑</title><link>http://localhost:1313/post/c++%E9%9D%A2%E8%AF%95%E6%B7%B1%E5%9D%91/</link><pubDate>Tue, 15 Aug 2023 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/c++%E9%9D%A2%E8%AF%95%E6%B7%B1%E5%9D%91/</guid><description>&lt;blockquote>
&lt;p>永远不要在面试官前表示自己精通 C++ ，你会死的很惨的&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>如果你在自己的简历上敢写自己的主要编程语言是 C++ 的话，那么恭喜你，你已经走上了最困难的一条路。如果你不是计算机系科班出身，或者对所有的计算机知识至少留有印象的话，那么你可能会被下到汇编、操作系统，上到编程算法被问个体无完肤。不过另一方面，如果你真的可以打好 C++ 的基础，那么计算机的其他部分你肯定可以触类旁通，畅行于计算机的世界而毫无困难。&lt;/p>
&lt;p>这个文章希望记录我遇到的和我知道的在面试中，C++ 可能会被面到的问题。其中包括 C++ 的基础，汇编、操统、计算机组成等计算机核心知识，还会包括一些稀奇古怪的题目。希望能够帮到一些同样主要编程语言是 C/C++ ，并且希望能够更加深入了解计算机的人们。&lt;/p>
&lt;h2 id="c-语言">C 语言&lt;/h2>
&lt;h3 id="基本数据类型的大小">基本数据类型的大小&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdbool.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(char) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(unsigned char) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(short) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">short&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(bool) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">bool&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(int) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(unsigned int) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(long) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(unsigned long) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(long long) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(unsigned long long) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(void *) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(&amp;#39;hello world&amp;#39;) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(float) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">float&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;sizeof(double) = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(char) = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(unsigned char) = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(short) = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(bool) = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(int) = 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(unsigned int) = 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(long) = 8 // 64 位 unix 为 8B, x86-64 为 4B
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(unsigned long) = 8 // 64 位 unix 为 8B, x86-64 为 4B
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(long long) = 8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(unsigned long long) = 8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(void *) = 8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(&amp;#39;hello world&amp;#39;) = 12
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(float) = 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> sizeof(double) = 8
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的内容都是最为基础的知识，或者说它们大多没有什么需要注意的地方，基本上背诵记忆即可。&lt;/p>
&lt;p>不过仔细想想，有一些多少可以讲解一点的东西，我们来看一下：&lt;/p>
&lt;h4 id="基础的大小单位">基础的大小单位&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>比特 bit
0，1 两个值，是数据处理和储存的最小单位，代表两个状态。一般在电脑中利用电平表示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字节（Byte）
一个字节 8 bit。（别问！字节的大小是定义的，现在就是 8 位，就当没有什么理由就可以了。）&lt;/p>
&lt;p>最经典的一个字节长的东西就是 char，对应一个 ascii 码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字 WORD
定义为两个字节，8B, 16 bits&lt;/p>
&lt;p>经典的一个字大小的东西是 short&lt;/p>
&lt;/li>
&lt;li>
&lt;p>双字 DWORD&lt;/p>
&lt;p>如同字面意思，两个字的长度，32 bits&lt;/p>
&lt;p>int 的大小，实在没有什么好说的了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>四字 QWORD&lt;/p>
&lt;p>字面意思 4 个字长度，64 bits&lt;/p>
&lt;p>典型的 64 位大小为 c++11 后的 long long 类型长度以及 64 位机的指针大小（毕竟地址线宽就是 64 位，指针当然也得是 64 位）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字长&lt;/p>
&lt;p>字长和字节虽然有同样的一个字，不过这两个概念没有半毛钱关系！&lt;/p>
&lt;p>你可以认为字长是计算机的传输线宽，计算机的各种组成单元在一次存取、加工、传送时可以使用的数据长度就是字长。&lt;/p>
&lt;p>我们常说的 32位机、64位机说的就是字长&lt;/p>
&lt;p>我们以 64 位机为例子，字长为 8B&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="指针的大小">指针的大小&lt;/h4>
&lt;p>指针的大小永远和计算机的字长一样大，所以如果是 32 位的电脑就是 4 字节，64 位就是 8 字节&lt;/p>
&lt;h4 id="字符串的大小">字符串的大小&lt;/h4>
&lt;p>&lt;code>&amp;quot;hello world&amp;quot;&lt;/code> 一共 11 个字母，但是长度为 12B ，因为字符串的末尾会被添加 \0 作为终止符号。&lt;/p>
&lt;h3 id="struct-的内存结构">struct 的内存结构&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="c-plus-plus-语言">C++ 语言&lt;/h2>
&lt;h3 id="类的成员函数">类的成员函数&lt;/h3>
&lt;p>&lt;a href="https://blog.csdn.net/fuzhongmin05/article/details/59112081">https://blog.csdn.net/fuzhongmin05/article/details/59112081&lt;/a>&lt;/p>
&lt;p>请回答下面的问题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">D&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;func1&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;func2&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> D&lt;span style="color:#f92672">*&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> D(), &lt;span style="color:#f92672">*&lt;/span>b &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">-&amp;gt;&lt;/span>func1(); &lt;span style="color:#75715e">// func1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> a&lt;span style="color:#f92672">-&amp;gt;&lt;/span>func2(); &lt;span style="color:#75715e">// func2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(a) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#75715e">// 8 (64 bit)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>a) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl; &lt;span style="color:#75715e">// 16 (虚指针 + 对齐后的 char)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b&lt;span style="color:#f92672">-&amp;gt;&lt;/span>func1(); &lt;span style="color:#75715e">// func1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> b&lt;span style="color:#f92672">-&amp;gt;&lt;/span>func2(); &lt;span style="color:#75715e">// segmentfault
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="多态">多态&lt;/h3>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/529726280">https://zhuanlan.zhihu.com/p/529726280&lt;/a>&lt;/p>
&lt;p>请回答下面的问题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;funcA&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">nfunc&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;nfuncA&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;funcB&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">nfunc&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;nfuncB&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print_func1&lt;/span>(A&lt;span style="color:#f92672">*&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>func();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>nfunc();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print_func2&lt;/span>(A&lt;span style="color:#f92672">&amp;amp;&lt;/span> p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.func();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p.nfunc();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> B&lt;span style="color:#f92672">*&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> B();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A&lt;span style="color:#f92672">*&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">-&amp;gt;&lt;/span>func(); &lt;span style="color:#75715e">// funcB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> a&lt;span style="color:#f92672">-&amp;gt;&lt;/span>nfunc(); &lt;span style="color:#75715e">// nfuncA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> b&lt;span style="color:#f92672">-&amp;gt;&lt;/span>func(); &lt;span style="color:#75715e">// funcB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> b&lt;span style="color:#f92672">-&amp;gt;&lt;/span>nfunc(); &lt;span style="color:#75715e">// nfuncB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>a).func(); &lt;span style="color:#75715e">// funcB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>a).nfunc(); &lt;span style="color:#75715e">// nfuncA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>b).func(); &lt;span style="color:#75715e">// funcB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>b).nfunc(); &lt;span style="color:#75715e">// nfuncB
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> print_func1(a); &lt;span style="color:#75715e">// funcB, nfuncA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> print_func1(b); &lt;span style="color:#75715e">// funcB, nfuncA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> print_func2(&lt;span style="color:#f92672">*&lt;/span>a); &lt;span style="color:#75715e">// funcB, nfuncA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> print_func2(&lt;span style="color:#f92672">*&lt;/span>b); &lt;span style="color:#75715e">// funcB, nfuncA
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="计算机网络">计算机网络&lt;/h2>
&lt;h2 id="操作系统">操作系统&lt;/h2>
&lt;h3 id="物理内存和虚拟内存">物理内存和虚拟内存&lt;/h3>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/529726280">https://zhuanlan.zhihu.com/p/529726280&lt;/a>&lt;/p></description></item><item><title>WIP: 刷题时永远记不住的东西</title><link>http://localhost:1313/post/leetcode_notes/</link><pubDate>Tue, 15 Aug 2023 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/leetcode_notes/</guid><description>&lt;blockquote>
&lt;p>刷题时不可能刷题的，这辈子都不可能刷题的。&lt;/p>
&lt;p>学校里个个都是人才，说话也好听，我超喜欢在里面的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="数组">数组&lt;/h2>
&lt;blockquote>
&lt;p>数组，为什么是神？
在回答这个问题之前，我们必须要解释清楚，神和其他的数据结构都有什么区别。
首先是犯下傲慢之罪的栈和队列。只是在数组的上增加了一些小创新，就妄图宣称自己是全新的数据结构。数组念在其本是同根生的份上，没有多加追究。允许它们发扬光大是神最大的慈悲。
其次是犯下懒惰之罪的队列。除了进出 O(1) 开销竟然所有操作都是 O(n) 代价。如同只会吃喝拉撒却一点活不干废物一样。这样的数据结构终将受到神的惩罚。
再次是犯下嫉妒之罪的二叉树和堆。明明是平衡二叉树（AST）的退化，但是因为嫉妒数组的空间开销，偷去了数组的格式，储存着树状的数据，美名其曰新的数据结构。这样的数据结构必将被神绳之以法。
最后是犯下愤怒之罪的哈希表。为了追求极致的快速访问失去了理性，背叛了数组的简单优雅，不仅试图往一个下标里塞进多个元素，连键值和下标都已经不对应了。这种数据结构已经被神开除了数组籍，被隔壁的 map 收留，成为了 unordered_map。
神是宽容的，也是慈悲的。
纵使树的各种不同分支不断发展壮大，纵使各类新型的编程语言支持的基本容器都增加了键值对，神也不纠不缠。
神是万物的起源，是众生的归宿。
组门！&lt;/p>
&lt;/blockquote>
&lt;h3 id="求数组中最大的前两个数以及其对应的下标">求数组中最大的前两个数以及其对应的下标&lt;/h3>
&lt;p>只需要 4 个变量即可做到&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> max2(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> max_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, max_1_idx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> max_2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, max_2_idx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nums.size(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(nums[i] &lt;span style="color:#f92672">&amp;gt;&lt;/span> max_1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_2 &lt;span style="color:#f92672">=&lt;/span> max_1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_2_idx &lt;span style="color:#f92672">=&lt;/span> max_1_idx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_1 &lt;span style="color:#f92672">=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_1_idx &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span>(nums[i] &lt;span style="color:#f92672">&amp;gt;&lt;/span> max_2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_2 &lt;span style="color:#f92672">=&lt;/span> nums[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_2_idx &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> res(&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> {max_1, max_1_idx, max_2, max_2_idx};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="二分搜索">二分搜索&lt;/h2>
&lt;blockquote>
&lt;p>别跟老子说什么堆、滑动窗口、单调队列
数组中搜索老子就是二分
先排序再二分，左右横竖 nlogn
管他找什么数的题目，二分就完事了&lt;/p>
&lt;/blockquote>
&lt;h3 id="基础算法">基础算法&lt;/h3>
&lt;p>一个最简单的实现如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [l, r]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果存在则返回下标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果不存在则返回 -1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">search&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> nums.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(left &lt;span style="color:#f92672">&amp;lt;=&lt;/span> right){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> (right &lt;span style="color:#f92672">-&lt;/span> left) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> left;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> nums[mid];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">==&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (num &lt;span style="color:#f92672">&amp;gt;&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个是 leetcode 的样例代码，我更喜欢左闭右开的写法（不要记住这个！很容易写出错误！）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">bsearch&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, r &lt;span style="color:#f92672">=&lt;/span> a.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> (l &lt;span style="color:#f92672">+&lt;/span> r) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(l &lt;span style="color:#f92672">&amp;lt;&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mid &lt;span style="color:#f92672">=&lt;/span> (l &lt;span style="color:#f92672">+&lt;/span> r) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(a[mid] &lt;span style="color:#f92672">&amp;gt;&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> mid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(a[mid] &lt;span style="color:#f92672">&amp;lt;&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(a[mid] &lt;span style="color:#f92672">==&lt;/span> num) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="若干特例">若干特例&lt;/h3>
&lt;h4 id="不超过-不小于">不超过、不小于&lt;/h4>
&lt;p>有两个非常经典的问题：&lt;/p>
&lt;ol>
&lt;li>找到有序数组中不超过特定数的最大数&lt;/li>
&lt;li>找到有序数组中不小于特定数的最小数&lt;/li>
&lt;/ol>
&lt;p>这两个问题使用样例代码非常简单&lt;/p>
&lt;p>当 search 函数返回 -1 的时候，它的 left 和 right 一定在搜索数的两端，left 在比搜索数大的一端，right 在比搜索数小的一端。这个特性不会因为数组中的重复元素而发生变化。但是如果使用左闭右开的方法的话，就一定会出现问题（所以一定要背标准答案啊！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>[1, 4, 4, ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bsearch end with: l 1, r 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bsearch: find nums 2, -1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>search end with: left 1, right 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>search: find nums 2, -1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>====
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[1, 1, 4, ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bsearch end with: l 2, r 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bsearch: find nums 2, -1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>search end with: left 2, right 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>search: find nums 2, -1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么上面的两个问题就转化成了：&lt;/p>
&lt;ol>
&lt;li>如果可以找到特定数，那么直接返回它就可以&lt;/li>
&lt;li>如果没有找到特定数，那么如果需要不大于它的值，则使用 right 对应的数；如果需要不小于它的值，则使用 left 对应的数&lt;/li>
&lt;/ol>
&lt;h4 id="返回特定数最左或者最右的下标">返回特定数最左或者最右的下标&lt;/h4>
&lt;p>假如说一个数组中有大量重复的元素，那么问题可能会要求你返回这个元素靠近较小数字的下标，或者靠近较大数字的下标。&lt;/p>
&lt;p>样例的 search 也无法做到这一点，因为它会在搜索到 target 的时候立刻停止。&lt;/p>
&lt;p>我通常的做法是，先搜索到那个特定数，然后直接向左或者向右搜索，直到尽头。一般来说效率不是特别高。&lt;/p>
&lt;p>一个奇妙的做法是：对于整数题目可以把二分搜索改为 double 类型，然后搜索这个数 +- 0.5。应该可以解决问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> double_search(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">double&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, r &lt;span style="color:#f92672">=&lt;/span> a.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(l &lt;span style="color:#f92672">&amp;lt;=&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mid &lt;span style="color:#f92672">=&lt;/span> (l &lt;span style="color:#f92672">+&lt;/span> r) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(a[mid] &lt;span style="color:#f92672">&amp;gt;&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span>(a[mid] &lt;span style="color:#f92672">&amp;lt;&lt;/span> target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_pair(l, r);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_pair(l, r);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>[1, 1, 2, 2, 2, 4, ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bsearch: find nums 2, 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>search: find nums 2, 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>double search: find nums 2.0, left 5, right 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>double search: find nums 1.5, left 2, right 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="快排">快排&lt;/h2>
&lt;p>总是背不下来的快排。&lt;/p>
&lt;p>我已经写了一篇快排的笔记了，现在就在这里也记录一下吧。&lt;/p>
&lt;p>一个最简单的快排算法真的不需要多少代码。需要记忆的内容也只有几个，我们跟着代码来一起记忆。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. [l, r] 记住我们的代码是左闭右闭的区间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">qsort&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> l, &lt;span style="color:#66d9ef">int&lt;/span> r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(l &lt;span style="color:#f92672">&amp;gt;=&lt;/span> r) &lt;span style="color:#66d9ef">return&lt;/span>; &lt;span style="color:#75715e">// 2. 边界条件一定要判断
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> pivot &lt;span style="color:#f92672">=&lt;/span> a[l], ll &lt;span style="color:#f92672">=&lt;/span> l, rr &lt;span style="color:#f92672">=&lt;/span> r; &lt;span style="color:#75715e">// 3. pivot 如果想写的简单一点就最左边这个数就可以，不过记住是 a[l] 不是 a[0]!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>(ll &lt;span style="color:#f92672">&amp;lt;&lt;/span> rr) { &lt;span style="color:#75715e">// 4. 这个循环条件必不可少，决定了能否找到 pivot 真正的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 5. while 循环中的 ll &amp;lt; rr 作为先制条件不能删除！这可以保证 ll 永远不会超过 rr，使得 swap 可以放心进行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 6. rr-- 的 while *必须* 在 ll++ 的循环之前！否则对于像是 [1, 2, 2, 2, 2] 的数组，ll 与 rr 不能正确地找到自己的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// （也就是一个元素本身就是最小的数，我们必须保证两个指针在最左侧相遇，所以为了防止这种情况，ll 必须晚于 rr 移动）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>(ll &lt;span style="color:#f92672">&amp;lt;&lt;/span> rr &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a[rr] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> pivot) rr&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(ll &lt;span style="color:#f92672">&amp;lt;&lt;/span> rr &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a[ll] &lt;span style="color:#f92672">&amp;lt;=&lt;/span> pivot) ll&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a[ll], a[rr]); &lt;span style="color:#75715e">// 7. swap ，不难理解
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a[l], a[ll]); &lt;span style="color:#75715e">// 8. ll 与 rr 必然都在 pivot 该在的地方，这时候交换 pivot(a[l]) 与 ll 的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> qsort(a, l, ll &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>); &lt;span style="color:#75715e">// 9. 再做两次 qsort 进行分治，ll 位置已经不需要再进行排序了，所以 ll - 1, 与 ll + 1 就很合理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> qsort(a, ll &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, r);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最关键的几个：&lt;/p>
&lt;ol>
&lt;li>左闭右闭&lt;/li>
&lt;li>pivot = a[l]&lt;/li>
&lt;li>while(ll &amp;lt; rr)&lt;/li>
&lt;li>先 rr&amp;ndash; 再 ll++&lt;/li>
&lt;li>里面 swap ll, rr，外面 swap a[l], a[ll]&lt;/li>
&lt;li>分治&lt;/li>
&lt;/ol>
&lt;h2 id="字符串">字符串&lt;/h2>
&lt;p>字符串考察的内容非常综合，几乎所有的考题都可以从字符串中出出来。其中最基础的是字符串的输入输出，这是 ACM 题目的最基本的一步；其次是数组，因为字符串一般都是用数组储存的；再然后是动归、字符串处理这些更加复杂的算法。在这里我们没办法把所有字符串处理的内容都记录下来，只能就其中比较基础和简单的问题进行一下讨论。&lt;/p>
&lt;h3 id="字符串基础小知识">字符串基础小知识&lt;/h3>
&lt;h4 id="字符串的元素顺序">字符串的元素顺序&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>问题：对于字符串 &amp;ldquo;123456&amp;rdquo; 而言，哪个数字的下标是 0 ？&lt;/p>
&lt;p>答案：1&lt;/p>
&lt;p>这个问题不能想，必须一下子回答出来。无论是什么编程语言，都是左边的字符下标小，右边的字符下标大。如同写字是从左往右写的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="反转字符串">反转字符串&lt;/h4>
&lt;p>&lt;a href="https://blog.csdn.net/u014339447/article/details/109232871">https://blog.csdn.net/u014339447/article/details/109232871&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>string &lt;span style="color:#a6e22e">reverse&lt;/span>(string s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> string(s.rbegin(), s.rend());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="c-c-plus-plus-的输出输出与字符串">C/C++ 的输出输出与字符串&lt;/h3>
&lt;p>众所周知，C/C++ 的输入输出是出了名的费劲，不过我们必须牢记这个过程。&lt;/p>
&lt;h4 id="基础输入输出">基础输入输出&lt;/h4>
&lt;p>16 进制的读写&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>scanf(&lt;span style="color:#e6db74">&amp;#34;%X&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>x); &lt;span style="color:#75715e">// %x 也可以
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>printf(&lt;span style="color:#e6db74">&amp;#34;%#x&amp;#34;&lt;/span>, x); &lt;span style="color:#75715e">// 这样打印会有 0x 前缀
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>%#x：输出带有 0x 前缀的十六进制数。&lt;/li>
&lt;/ul>
&lt;p>浮点数的输入输出&lt;/p>
&lt;p>scanf 只能读入 float !&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> f;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scanf(&lt;span style="color:#e6db74">&amp;#34;%f&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>f); &lt;span style="color:#75715e">// %e, %E, %g 也可以读入
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>printf(&lt;span style="color:#e6db74">&amp;#34;%0.2f&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0.114514&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#e6db74">&amp;#34;%+E&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">103801801.0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#e6db74">&amp;#34;%+lf&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">103801801&lt;/span>); &lt;span style="color:#75715e">// 不要这样！会输出 0.0000 。数据类型一定要正确！
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>%-10s：左对齐并占用宽度为 10 的字符串；&lt;/li>
&lt;li>%+4d：右对齐并占用宽度为 4，强制显示正负号的整数；&lt;/li>
&lt;li>%5.2f：右对齐并占用宽度为 5，保留两位小数的浮点数；&lt;/li>
&lt;/ul>
&lt;p>不知道长度的输入输出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">char&lt;/span> ans[&lt;span style="color:#ae81ff">10&lt;/span>][&lt;span style="color:#ae81ff">100&lt;/span>]; &lt;span style="color:#75715e">// 10 个长度为 100 的字符数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">while&lt;/span>(scanf(&lt;span style="color:#e6db74">&amp;#34;%s&amp;#34;&lt;/span>, ans[num]) &lt;span style="color:#f92672">!=&lt;/span> EOF) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>num &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>string s[&lt;span style="color:#ae81ff">10&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> s[num]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>C++ split&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> input[&lt;span style="color:#ae81ff">16&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;abc,d&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 如果找到了分隔符的话，strtok 会在分隔符前加上一个 \0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p &lt;span style="color:#f92672">=&lt;/span> strtok(input, &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// 这个函数会破坏原有的字符串，如果需要源字符串则你需要复制一份
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 之后调用 strtok 需要使用 NULL 作为第一个参数。如果可以分割，则返回字符串指针。如果不行则返回 NULL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> p &lt;span style="color:#f92672">=&lt;/span> strtok(NULL, &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">；&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="最长公共子序列-简单的动归">最长公共子序列：简单的动归&lt;/h4>
&lt;p>一个朴素的 DP 题目&lt;/p>
&lt;h4 id="字符串匹配-超难动归-kmp">&lt;!-- raw HTML omitted -->TODO&lt;!-- raw HTML omitted --> 字符串匹配：超难动归 KMP&lt;/h4>
&lt;p>暂时我解释不清楚这个算法，之后再来补上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">buildNext&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>P) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t m &lt;span style="color:#f92672">=&lt;/span> strlen(P), j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>N &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>[m];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> N[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(j &lt;span style="color:#f92672">&amp;lt;&lt;/span> m &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (t &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> P[j] &lt;span style="color:#f92672">==&lt;/span> P[t]) &lt;span style="color:#f92672">?&lt;/span> N[&lt;span style="color:#f92672">++&lt;/span>j] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">++&lt;/span>t : t &lt;span style="color:#f92672">=&lt;/span> N[t];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> N;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">match&lt;/span>(&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>P, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> buildNext(P);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> strlen(T), i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> strlen(P), j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(j &lt;span style="color:#f92672">&amp;lt;&lt;/span> m &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(j &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> T[i] &lt;span style="color:#f92672">==&lt;/span> P[j]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>; j&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">=&lt;/span> next[j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span>[] next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> j;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="滑动窗口">滑动窗口&lt;/h2>
&lt;p>滑动窗口是一种可以明显降低时间复杂度的方案。滑动窗口可以使得每一次处理的时间和空间都局限在一个窗口内部，这使得一个 O(N) 的问题可以变成每一次 O(k) 处理，一共处理 O(N) 次。滑动窗口问题最困难的部分有两个：一个是每个窗口应该如何处理，二是每次改变窗口的时候应该如何处理。&lt;/p>
&lt;p>滑动窗口问题需要首先解决一个问题：应该怎么维护一个窗口？&lt;/p>
&lt;p>一般来说一个窗口都是从下标 i 到下标 i + k 的一段区域所设计的元素，我们一般的操作都是要把这个窗口的元素放到某个数据结构当中，然后维护这个窗口。那么我们至少涉及三个操作：向数据结构中增加元素、在数据结构中搜索要删除的元素、删除这个元素。一般来说我们希望时间复杂度不要超过 log(n)，那么我们稍微分析一下这其中的时间开销。&lt;/p>
&lt;p>添加数据和删除数据一般不需要大量的时间开销。哪怕使用开销最大的数组作为数据结构，那么我们通常总是可以使用两个指针来表明窗口，而不需要手动维护一个完整的数组（毕竟数组主要是用来储存连续的数据的，如果需要维护特征的话我们肯定需要使用其他的数据结构）&lt;/p>
&lt;p>那么就可以发现，绝大部分需要优化的东西都留在了搜索要删除的元素。如果可以把这个工作压到 O(1) ，一般程序就是 O(n) 复杂度了；哪怕不得不是 O(logn) 的时间也是整体 O(nlogn) 的时间。&lt;/p>
&lt;p>那么之后分析滑动窗口的问题就非常简单了，我们只需要针对窗口的变化，熟悉我们需要使用的多种不同的数据结构以及维护变化的方法就好了。我们结合题目来进行分析。&lt;/p>
&lt;h3 id="滑动窗口最大值-堆-单调队列">滑动窗口最大值（堆，单调队列）&lt;/h3>
&lt;p>这是一道非常经典的题目，也是滑动窗口中最朴素的复合题目。&lt;/p>
&lt;p>滑动窗口的第一个可用的工具就是堆，因为它总是能维护一个最大值或者最小值。&lt;/p>
&lt;h4 id="堆">堆&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>
&lt;p>priority_queue 的特性&lt;/p>
&lt;p>我们先来总结一些奇妙的 priority_queue 特性：&lt;/p>
&lt;ol>
&lt;li>priority_queue 对于 Pair 有自己默认的排序方法，先后比较 first ，而且优先使用 &amp;lt; 比较符号。所以使用 pair&amp;lt;int, int&amp;gt; 你可以得到一个大根堆：首先是按照第一个元素从大到小排序，然后是按照第二个元素从大到小排序&lt;/li>
&lt;li>priority_queue.emplace 函数可以就地使用构造函数插入一个新的量。&lt;/li>
&lt;li>priority_queue 并不是一个 set，它里面所有的元素是可以重复的！不过这些重复的元素并没有任何提示说明他们什么时候进入的队列&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> pq1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq1.push(i &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(pq1.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%d, &amp;#34;&lt;/span>, pq1.top());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq1.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 7, 7, 6, 6, 5, 5, 4, 4,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> pq2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">auto&lt;/span> e: {pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>}, pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>}, pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>}, pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>}, pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>}}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq2.push(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(pq2.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;(%d, %d), &amp;#34;&lt;/span>, pq2.top().first, pq2.top().second);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pq2.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// (5, 3), (5, 2), (3, 4), (2, 5), (1, 2),
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>
&lt;p>滑动窗口与堆：只要知道什么时候删除&lt;/p>
&lt;p>堆最主要的问题就是说我们没办法只用一个元来维护窗口。因为堆中搜索元素需要 O(N) ，我们根本无法每次都遍历堆然后增减元素。所以我们的思路有两个：&lt;/p>
&lt;ol>
&lt;li>加快堆搜索元素的效率，比如说把堆中的每个元素和一个搜索结构对应起来（比如说一个 map）&lt;/li>
&lt;li>想办法保证需要删除的元素一定在堆顶（毕竟堆中的其他元素实际上是有一定顺序的，并不需要担心加入数据的时候出现太多问题）&lt;/li>
&lt;/ol>
&lt;p>第一个思路比较朴素，我们可以维护一个 unordered_map 来解决这个问题。记录窗口中所有的元素，并且使用 unordered_map 来维护窗口中元素的个数。然后让 priority_queue 记录 map 中的元素指针就可以做到。但是这也太复杂了，完全没有那个必要。&lt;/p>
&lt;p>第二个思路直接看起来有些困难，我们不妨反过来思考：我们不去考虑找到所有需要删除的元素，只去考虑堆顶的元素什么时候需要被删除即可。也就是说，我们不需要维护堆中的每一个元素，保证他们都在窗口中，我们只要保证我们的堆顶元素在窗口中，那么我们给出的一定是正确答案。解题思路一下子就改成了：&lt;/p>
&lt;ol>
&lt;li>如何确认堆顶元素在窗口中：记录每个元素的下标，在插入元素的时候就可以根据窗口大小知道这个元素是否在窗口中&lt;/li>
&lt;li>如何维护堆顶元素在窗口中：每次添加新元素的时候检查堆顶元素，如果不在窗口中就删去。重复此步骤，直到满足条件为止&lt;/li>
&lt;/ol>
&lt;p>现在我们就可以利用 priority_queue 的特性，利用一个 pair 来书写这个程序了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> maxSlidingWindow(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> q;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.emplace(nums[i], i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> {q.top().first};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.emplace(nums[i], i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 下面这个步骤是最关键的，删除栈顶元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (q.top().second &lt;span style="color:#f92672">&amp;lt;=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans.push_back(q.top().first);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 作者：力扣官方题解
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 链接：https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 来源：力扣（LeetCode）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="单调队列">单调队列&lt;/h4>
&lt;p>单调队列是采用双向队列 deque 的一种处理滑动窗口问题的巧妙方法。它的维护数据结构的逻辑稍微有一点复杂，思路如下：
我们先准备一个双向队列，它像是传送带一样：我们需要的元素都在它的头部，我们可能需要的数据都在它的中间，我们不需要的数据根本不会进入队列。这有一点像堆，但是我们需要手动维护这个队列。（为什么偏偏要选择一个更难的方法维护？因为有些题目没办法用堆）&lt;/p>
&lt;p>对于任何后来的数据而言，它们离开窗口的时间一定晚于之前的数据。如果它们相对于等待的数据而言更加符合题目要求（更优秀）的话，那么排在队尾的一系列数据就都失去了意义：新的数据到来意味着，它们无论在前一个窗口还是后一个窗口都不会被需要，所以只能被淘汰。这样我一定能保证队列中的数据要么是当前窗口最好的，要么是下一个窗口中比较好的，队列中一定不会有没有用的数据。然后需要从队首舍弃一系列过期的数据，这样就可以完成对数据的维护。&lt;/p>
&lt;p>有一个不错的比喻就是，这个很像是公司招人。窗口就是一个时间段，头就是这段时间里最优秀的人，中间就是次优的人，其他不够优秀的人完全进不了队列。首先，你为了进入公司，你至少需要比公司里的比较优秀的人要好；要是有新人进来后，发现公司里有很多人还没有新人厉害，那么新人有强，干得时间又久，那么队列中那些中间的人就一定不会出头，他们也就不被需要了。然后我们需要处理的就是太老的人，我们需要把它们舍弃，因为退休时间到了。你看，就这么简单。&lt;/p>
&lt;p>对于这道题来说，我们队列中维护的并不是数值，而是下标。单向队列必须要维护下标，因为除此之外我们无法得知窗口什么时候结束。简单的流程如下：&lt;/p>
&lt;ol>
&lt;li>对于每一个新成员，检查是否比队尾的成员优秀。持续删除队尾元素，直到队列中没有元素，或者新数据不够优秀为止。&lt;/li>
&lt;li>让新成员加入&lt;/li>
&lt;li>持续删除队首的超时数据&lt;/li>
&lt;li>输出答案&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> maxSlidingWindow(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deque&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> q;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>q.empty() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> nums[i] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> nums[q.back()]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop_back();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> {nums[q.front()]};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> k; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>q.empty() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> nums[i] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> nums[q.back()]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop_back();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (q.front() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop_front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ans.push_back(nums[q.front()]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">作者：力扣官方题解
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">链接：https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">来源：力扣（LeetCode）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="链表">链表&lt;/h2>
&lt;h3 id="链表的指针操作">链表的指针操作&lt;/h3>
&lt;p>链表题目都不会给双向链表，我们只能使用单向链表。单向链表最大的问题就是它只能往一个方向遍历，这使得我们无法直接随机访问链表中的元素。有的时候，链表还会对访问若干相邻的元素产生障碍，尤其是需要处理边界条件的时候，可能会让人非常抓狂。在面试的时候去 debug segment fault 真的非常折磨。&lt;/p>
&lt;h4 id="反转链表">反转链表&lt;/h4>
&lt;p>&lt;a href="https://leetcode.cn/problems/UHnkqh/solutions/1022382/fan-zhuan-lian-biao-by-leetcode-solution-34oi/">https://leetcode.cn/problems/UHnkqh/solutions/1022382/fan-zhuan-lian-biao-by-leetcode-solution-34oi/&lt;/a>&lt;/p>
&lt;p>必须要会的小技巧，最大的问题是处理边界条件。&lt;/p>
&lt;p>提问：为了反转链表，你需要至少新定义多少个新的指针？
答案是三个，你至少需要前一个节点（作为当前节点的 next），当前节点和下一个节点（否则会被替代掉）&lt;/p>
&lt;p>可以这样记忆这个算法：3-4-5（三个临时变量，while 里面四行，返回 prev）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">reverseList&lt;/span>(ListNode &lt;span style="color:#f92672">*&lt;/span>head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> prev &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>; &lt;span style="color:#75715e">// 注意第一个指针需要是 NULL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ListNode&lt;span style="color:#f92672">*&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> next &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(curr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next &lt;span style="color:#f92672">=&lt;/span> curr&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next; &lt;span style="color:#75715e">// 临时储存 curr-&amp;gt;next
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> curr&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#f92672">=&lt;/span> curr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> prev;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>递归版本也是一道不错的思维题目，我们在下面写一下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>ListNode&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">reverseListRecur&lt;/span>(ListNode &lt;span style="color:#f92672">*&lt;/span>head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(head &lt;span style="color:#f92672">==&lt;/span> NULL &lt;span style="color:#f92672">||&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">==&lt;/span> NULL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> newHead &lt;span style="color:#f92672">=&lt;/span> reverseListRecur(head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 考虑最前面的三个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> head newHead
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 1 -&amp;gt; 2 -&amp;gt; 3 &amp;lt;-4567...n
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> ^ |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> | |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> +----+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> head newHead
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 1 -&amp;gt; 2 &amp;lt;- 3 &amp;lt;-4567...n
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> head; &lt;span style="color:#75715e">// 让已经反转过的链表末尾变成自己
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>; &lt;span style="color:#75715e">// 如果自己是第一个元素，那么就不会有新的节点修改这个值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> newHead; &lt;span style="color:#75715e">// newHead 一定是原来链表的末尾
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="奇偶链表">&lt;!-- raw HTML omitted -->TODO&lt;!-- raw HTML omitted --> 奇偶链表&lt;/h4>
&lt;h4 id="合并链表">&lt;!-- raw HTML omitted -->TODO&lt;!-- raw HTML omitted --> 合并链表&lt;/h4>
&lt;h3 id="快慢指针">快慢指针&lt;/h3>
&lt;p>没有什么是比快慢指针更加朴素无华，但是又非常华丽的算法了。&lt;/p>
&lt;p>链表天生的 O(n) 遍历时间确实让人头皮发麻，但是使用了快慢指针后，我们可以方便地得知一个链表 1/s 的位置。通常用于得知链表一半的位置，也可以用来处理一些特殊的情况，例如环形链表&lt;/p>
&lt;h4 id="链表是否有环">链表是否有环&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 判断链表有环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 有一个非常不错的双指针方法，在 leetcode 的同样题目下有关于链表比较详细的解析
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> next &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode(&lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>val &lt;span style="color:#f92672">=&lt;/span> v;}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;(%d)[%p]-&amp;gt;[%p]-&amp;gt;&amp;#34;&lt;/span>, val, &lt;span style="color:#66d9ef">this&lt;/span>, next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">has_loop&lt;/span>(ListNode&lt;span style="color:#f92672">*&lt;/span> start) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode &lt;span style="color:#f92672">*&lt;/span>first &lt;span style="color:#f92672">=&lt;/span> start, &lt;span style="color:#f92672">*&lt;/span>second &lt;span style="color:#f92672">=&lt;/span> start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(first &lt;span style="color:#f92672">!=&lt;/span> NULL &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> second &lt;span style="color:#f92672">!=&lt;/span> NULL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> second&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(second &lt;span style="color:#f92672">==&lt;/span> NULL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(second &lt;span style="color:#f92672">==&lt;/span> first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> second&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(second &lt;span style="color:#f92672">==&lt;/span> NULL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(second &lt;span style="color:#f92672">==&lt;/span> first) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> first &lt;span style="color:#f92672">=&lt;/span> first&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// char str[3];
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// std::cin&amp;gt;&amp;gt;str;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 正确的写法：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>ListNode&lt;span style="color:#f92672">&amp;gt;&lt;/span> nodes(&lt;span style="color:#ae81ff">3&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[i] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>].next &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>nodes[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[i].next &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>nodes[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 错误的写法:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// vector&amp;lt;ListNode&amp;gt; nodes;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// for(int i = 0;i &amp;lt; 3; ++i) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// nodes.push_back(ListNode(i));
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// if(i &amp;gt; 0) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// nodes[i - 1].next = &amp;amp;nodes[i];
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// if(i == 2) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// nodes[i].next = &amp;amp;nodes[0];
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这个代码会因为 vector 的 push_back 而导致内存地址变动，非常危险
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 如果想把 vector 当数组用，那么最好还是先分配好大小吧。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode &lt;span style="color:#f92672">*&lt;/span>start &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>nodes[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> has_loop(start) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="链表最大孪生和">链表最大孪生和&lt;/h4>
&lt;p>&lt;a href="https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/solutions/?envType=study-plan-v2&amp;amp;envId=leetcode-75">https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/solutions/?envType=study-plan-v2&amp;amp;envId=leetcode-75&lt;/a>&lt;/p>
&lt;p>简单描述题目就是把链表首尾之和求出来，然后删除首尾元素，继续求首尾元素的和，然后找最大值。&lt;/p>
&lt;p>虽然用栈是一个非常朴素无华且效率高的方法，但是要是 O(1) 的空间要求，应该怎么办呢？&lt;/p>
&lt;p>思路还是很朴素无华，当然就是快慢指针后反转链表了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ListNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> next &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode(&lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>val &lt;span style="color:#f92672">=&lt;/span> v;}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;(%d)[%p]-&amp;gt;[%p]-&amp;gt;&amp;#34;&lt;/span>, val, &lt;span style="color:#66d9ef">this&lt;/span>, next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">pairSum&lt;/span>(ListNode&lt;span style="color:#f92672">*&lt;/span> head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode &lt;span style="color:#f92672">*&lt;/span>slow &lt;span style="color:#f92672">=&lt;/span> head, &lt;span style="color:#f92672">*&lt;/span>fast &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(fast&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slow &lt;span style="color:#f92672">=&lt;/span> slow&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fast &lt;span style="color:#f92672">=&lt;/span> fast&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 此时 slow-&amp;gt;next 就是要翻转链表的起点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 我们复用这两个变量来翻转链表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> slow &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fast &lt;span style="color:#f92672">=&lt;/span> slow&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode&lt;span style="color:#f92672">*&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(fast) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp &lt;span style="color:#f92672">=&lt;/span> fast&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fast&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> slow;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slow &lt;span style="color:#f92672">=&lt;/span> fast;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fast &lt;span style="color:#f92672">=&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 此时 slow 就是新的 head
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> fast &lt;span style="color:#f92672">=&lt;/span> slow; &lt;span style="color:#75715e">// 从后往前遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> slow &lt;span style="color:#f92672">=&lt;/span> head; &lt;span style="color:#75715e">// 从前往后遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(slow &lt;span style="color:#f92672">!=&lt;/span> NULL &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> fast &lt;span style="color:#f92672">!=&lt;/span> NULL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, slow&lt;span style="color:#f92672">-&amp;gt;&lt;/span>val &lt;span style="color:#f92672">+&lt;/span> fast&lt;span style="color:#f92672">-&amp;gt;&lt;/span>val);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slow &lt;span style="color:#f92672">=&lt;/span> slow&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fast &lt;span style="color:#f92672">=&lt;/span> fast&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="堆">堆&lt;/h2>
&lt;h3 id="堆的定义">堆的定义&lt;/h3>
&lt;p>以小根堆为例：对于堆的每一个节点而言，该节点均比所有自己的子节点小，但是对于其他的子节点不需要关心顺序&lt;/p>
&lt;h3 id="手撸一个堆">手撸一个堆&lt;/h3>
&lt;h4 id="二叉堆">二叉堆&lt;/h4>
&lt;p>堆的储存：一般 vector 就足够了，我们使用线性二叉树来储存这个堆&lt;/p>
&lt;p>一个结点的子节点与父节点的下标为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 1 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 3 4 5 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 7 8 9 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, r &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> parent &lt;span style="color:#f92672">=&lt;/span> (i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请记住：如果你要在原来的数组上就地操作的话，你必须手动维护当前堆的大小 heapSize.&lt;/p>
&lt;h4 id="堆的更新-o--logn">堆的更新 O(log(N))&lt;/h4>
&lt;p>堆的每一次更新一定从堆的叶节点开始，向上一直传播到根节点。这个过程一定只会执行一次，不会重复执行。&lt;/p>
&lt;p>堆的更新可以分为两种：下沉与上浮&lt;/p>
&lt;p>下沉是从根节点开始，从上往下逐个与儿子中更小的那个进行比较，如果不满足堆的条件就进行交换，直到满足条件为止。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>12 14 16 18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># pop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>18 &amp;lt;-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8 &amp;lt; 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>12 14 16
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-&amp;gt; 18 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 12 &amp;lt; 14 16
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>12 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>18 14 16
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上浮则是相反，从下往上比较，如果不满足堆的条件则交换，直到满足为止。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>12 14 16 18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># push(2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>12 14 16 18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 &amp;lt;-
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-&amp;gt;2 14 16 18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-&amp;gt;2 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8 14 16 18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8 14 16 18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>12
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，建堆与删除操作会使用下沉，而增加操作会使用上浮。&lt;/p>
&lt;p>我们来看一个参考实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 例子都是大根堆
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 从 idx 位置开始进行下沉操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 大根堆找儿子结点中大的那个
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 小根堆找儿子结点中小的那个
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sink&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">int&lt;/span> heapSize) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, r &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>, largest &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (l &lt;span style="color:#f92672">&amp;lt;&lt;/span> heapSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a[l] &lt;span style="color:#f92672">&amp;gt;&lt;/span> a[largest]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest &lt;span style="color:#f92672">=&lt;/span> l;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (r &lt;span style="color:#f92672">&amp;lt;&lt;/span> heapSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a[r] &lt;span style="color:#f92672">&amp;gt;&lt;/span> a[largest]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest &lt;span style="color:#f92672">=&lt;/span> r;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (largest &lt;span style="color:#f92672">!=&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a[i], a[largest]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sink(a, largest, heapSize);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">goup&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> parent &lt;span style="color:#f92672">=&lt;/span> (i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(a[parent] &lt;span style="color:#f92672">&amp;lt;&lt;/span> a[i]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a[parent], a[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(parent &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> goup(a, parent);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我更喜欢迭代的实现方法，不过面试的时候永远是简单的越好。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sink&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">int&lt;/span> heapSize) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, r &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>, largest &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(l &lt;span style="color:#f92672">&amp;lt;&lt;/span> heapSize &lt;span style="color:#f92672">||&lt;/span> r &lt;span style="color:#f92672">&amp;lt;&lt;/span> heapSize) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (l &lt;span style="color:#f92672">&amp;lt;&lt;/span> heapSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a[l] &lt;span style="color:#f92672">&amp;gt;&lt;/span> a[largest]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest &lt;span style="color:#f92672">=&lt;/span> l;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (r &lt;span style="color:#f92672">&amp;lt;&lt;/span> heapSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a[r] &lt;span style="color:#f92672">&amp;gt;&lt;/span> a[largest]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest &lt;span style="color:#f92672">=&lt;/span> r;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (largest &lt;span style="color:#f92672">!=&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a[i], a[largest]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">=&lt;/span> largest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> l &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> largest &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">goup&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> parent &lt;span style="color:#f92672">=&lt;/span> (i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(true) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(a[parent] &lt;span style="color:#f92672">&amp;lt;&lt;/span> a[i]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(a[parent], a[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(parent &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">=&lt;/span> parent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parent &lt;span style="color:#f92672">=&lt;/span> (i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="floyd-建堆法o--n">floyd 建堆法O(N)&lt;/h4>
&lt;ol>
&lt;li>将所有的元素一股脑放进一个 vector 中，组成一个二叉树&lt;/li>
&lt;li>从最后一个 &lt;strong>非叶节点&lt;/strong> 开始，进行“下沉”操作&lt;/li>
&lt;li>逆序处理直到根节点为止。&lt;/li>
&lt;/ol>
&lt;p>总共的复杂程度不会超过 O(N)，具体证明忘记了。&lt;/p>
&lt;p>这里面最难的一步就是找到最后一个非叶节点的下标。我们不妨认为一共有 n 个数，那么最后一个非叶节点的坐标就是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">1 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">3 4* 5 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">7 8 9 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">n = 11-&amp;gt;4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">n = 10-&amp;gt;4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">build_heap&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> a.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> (n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// 实际上从 n / 2 出发也没有任何问题，不过我们还是严谨起见
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> start; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sink(a, i, len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="堆的操作">堆的操作&lt;/h4>
&lt;p>堆有三种操作：查看堆顶元素，插入一个元素，移除一个元素&lt;/p>
&lt;p>查看堆顶元素 top 只需要返回 heap[0] 即可。&lt;/p>
&lt;p>插入元素是在数组的末尾插入元素，然后对该元素进行上浮操作&lt;/p>
&lt;p>移除元素是将 top 元素与末尾的元素交换，缩减 heap 的大小，之后对根节点做下沉。&lt;/p>
&lt;h3 id="使用标准库">使用标准库&lt;/h3>
&lt;p>C++ 的堆标准库来自 &amp;lt;priority_queue&amp;gt; ，可以用下面的代码调用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;priority_queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> nums &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 优先级队列通常需要给三个参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 第一个参数是储存数据的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 第二个参数是储存数据的数据结构，一般使用 vector
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 第三个是比较函数，一般用 greater&amp;lt;T&amp;gt; 和 less&amp;lt;T&amp;gt; 就可以。其中 less&amp;lt;T&amp;gt; 是大根堆，greater&amp;lt;T&amp;gt;是小根堆
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>, less&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> big_root_heap(nums.begin(), nums.end());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> small_root_heap(nums.begin(), nums.end());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 top 函数获得栈顶元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> small_root_heap.top() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;gt; 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 使用 pop 函数删除元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> small_root_heap.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> small_root_heap.top() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;gt; 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 使用 push 增加元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> small_root_heap.push(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> small_root_heap.top() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;gt; 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="第-k-个最大的数">第 k 个最大的数&lt;/h3>
&lt;h2 id="迭代遍历">迭代遍历&lt;/h2>
&lt;p>您还在为遍历列表是空指针而痛苦吗，您还在为数组下标越界而苦恼吗，您还在为树的遍历不会而头痛吗？来到这里，我们都会一口气解决它们。&lt;/p>
&lt;h3 id="列表的两个两个走-奇偶链表">列表的两个两个走（奇偶链表）&lt;/h3>
&lt;h3 id="数组的二分">&lt;!-- raw HTML omitted -->TODO&lt;!-- raw HTML omitted --> 数组的二分&lt;/h3>
&lt;p>为了让大家不再害怕，我们就把二分可能产生的下标情况都列出来。&lt;/p>
&lt;h2 id="递归">递归&lt;/h2>
&lt;blockquote>
&lt;p>一朵名为栈溢出的乌云在程序员的头上飘着。&lt;/p>
&lt;/blockquote>
&lt;p>递归虽然危险很大，但是可以简化一大堆东西。千万不要因为占用栈的空间大而不去使用啊。&lt;/p>
&lt;ul>
&lt;li>全局状态的维护&lt;/li>
&lt;li>递归当前状态的维护&lt;/li>
&lt;li>递归返回值的讲究。&lt;/li>
&lt;li>递归与栈的使用&lt;/li>
&lt;/ul>
&lt;h2 id="二进制">二进制&lt;/h2>
&lt;blockquote>
&lt;p>就当是为了我，对它使用指数吧。&lt;/p>
&lt;/blockquote>
&lt;p>1,2,4,8 为核心的指数应该如何使用呢？&lt;/p>
&lt;h3 id="长除法的代码实现">长除法的代码实现&lt;/h3>
&lt;p>长除法一般的写法都是竖过来的，因为这样比较方便用手计算：&lt;/p>
&lt;p>2| 11 ^
&lt;del>&amp;mdash;&amp;ndash; &amp;ndash; 1 |
2| 5 |
+&amp;mdash;&amp;ndash; &amp;ndash; 1 |
2| 2 |
+&amp;mdash;&amp;ndash; &amp;ndash; 0 |
1 |
o&amp;mdash;&amp;mdash;&amp;mdash;&lt;/del>
(11)10 = (1011)2&lt;/p>
&lt;p>不过对于计算机来说，我们还是把它横过来写可能会更好一点：&lt;/p>
&lt;pre>&lt;code> 2 2 2 2
&lt;/code>&lt;/pre>
&lt;p>n 11&amp;mdash;&amp;gt;5&amp;mdash;&amp;gt;2&amp;mdash;&amp;gt;1&amp;mdash;&amp;gt;0
r 1 1 0 1
&amp;lt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;o&lt;/p>
&lt;p>可以看到，每次进行一次除 2 操作，然后查看除法过程中的余数（在计算机语言中，这个余数需要在除 2之前获得）。持续除 2 直到数字为 0 为止。&lt;/p>
&lt;p>很简单对吧，那么我们就来实现最简单的整数转二进制字符串。本题最复杂的步骤实际上是反转字符串。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>string &lt;span style="color:#a6e22e">trans&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> string s;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(n &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bit &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">/=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s.push_back(bit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> string(s.rbegin(), s.rend());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="二进制-1-的个数-简单">二进制 1 的个数（简单）&lt;/h3>
&lt;p>可以基于长除法解决&lt;/p>
&lt;h3 id="距离-n-最近的-2-的幂次-简单">距离 n 最近的 2 的幂次（简单）&lt;/h3>
&lt;h3 id="基础位运算优化">基础位运算优化&lt;/h3>
&lt;ul>
&lt;li>对 2 的幂次取模 == 对幂次 - 1 求与
&lt;ul>
&lt;li>n % 2 == n &amp;amp; 1&lt;/li>
&lt;li>n % 8 == n &amp;amp; 7&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>n &amp;amp; n - 1：长除法中的一步除法或求余&lt;/li>
&lt;/ul>
&lt;h3 id="快速幂运算">快速幂运算&lt;/h3>
&lt;p>递归&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> quickMul(&lt;span style="color:#66d9ef">double&lt;/span> x, &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (N &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> quickMul(x, N &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> N &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> y &lt;span style="color:#f92672">*&lt;/span> y : y &lt;span style="color:#f92672">*&lt;/span> y &lt;span style="color:#f92672">*&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">myPow&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> N &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> quickMul(x, N) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span> &lt;span style="color:#f92672">/&lt;/span> quickMul(x, &lt;span style="color:#f92672">-&lt;/span>N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>迭代&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> quickMul(&lt;span style="color:#66d9ef">double&lt;/span> x, &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> ans &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 贡献的初始值为 x
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> x_contribute &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在对 N 进行二进制拆分的同时计算答案
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (N &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (N &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ans &lt;span style="color:#f92672">*=&lt;/span> x_contribute;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将贡献不断地平方
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> x_contribute &lt;span style="color:#f92672">*=&lt;/span> x_contribute;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> N &lt;span style="color:#f92672">/=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ans;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">myPow&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> N &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> quickMul(x, N) &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span> &lt;span style="color:#f92672">/&lt;/span> quickMul(x, &lt;span style="color:#f92672">-&lt;/span>N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="动态规划">动态规划&lt;/h2>
&lt;blockquote>
&lt;p>动态规划如天书，虐我千题仍不足。状态转移加初始，整体有向无环图。&lt;/p>
&lt;/blockquote>
&lt;p>这个讲得实在是太好了，建议动态规划不懂的时候就去再看一遍。&lt;/p>
&lt;p>&lt;a href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/&lt;/a>&lt;/p>
&lt;h3 id="最大子序列之和">最大子序列之和&lt;/h3>
&lt;h3 id="最长上升子序列">最长上升子序列&lt;/h3>
&lt;h3 id="下降路径最小和">下降路径最小和&lt;/h3>
&lt;h2 id="前缀和">前缀和&lt;/h2>
&lt;p>前缀和在处理滑动窗口、数组子序列等问题上都可以有非常不错的发挥。我们要首先记住它的基础公式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>s[i] &lt;span style="color:#f92672">=&lt;/span> nums[i] &lt;span style="color:#f92672">+&lt;/span> s[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前缀和的基础公式非常简单，当前值就是之前值的和，而当前值就是把自己累加到之前的和上面。非常简单对不对。&lt;/p>
&lt;p>前缀和的第一个特点就是其可以非常简单地转换为区间和：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// sum of [l, r]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>sum &lt;span style="color:#f92672">=&lt;/span> s[r] &lt;span style="color:#f92672">-&lt;/span> s[l &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在一些滑动窗口的题目中需要求区间和，使用前缀和可以非常容易地完成。并且对于一些题目，甚至不需要储存所有的前缀和，而是只需要其中的两端。&lt;/p>
&lt;h3 id="例-1-最大连续1的个数-iii">例 1：最大连续1的个数 III&lt;/h3>
&lt;p>&lt;a href="https://leetcode.cn/problems/max-consecutive-ones-iii/?envType=list&amp;amp;envId=62ml08g">https://leetcode.cn/problems/max-consecutive-ones-iii/?envType=list&amp;amp;envId=62ml08g&lt;/a>&lt;/p>
&lt;p>这道题的标准解是一个滑动窗口与前缀和的结合。因为这样就可以便捷地计算窗口和。同时滑动窗口的好处是，每一个窗口，它的左端点和右端点基本上只有向右移动一个选项，这使得利用前缀和，我们只需要储存两个值即可：一个左端点的，一个右端点的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> longestOnes(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> nums, &lt;span style="color:#66d9ef">int&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> nums.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 前缀和(0 的个数)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> lsum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> , rsum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> max_window &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 滑动窗口 [l, r]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 其中 left 代表下一个要删除的端点下标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(right &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; right &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>right) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 延申右侧的端点，计算前缀和
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> rsum &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> nums[right];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果左侧的窗口不满足条件，那么需要进行缩减，直到满足条件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这里不需要 left &amp;lt; right 的条件，因为如果 left = right + 1，则说明此时为空窗口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 那么必然有 rsum - lsum == 0(rsum - lsum == 0 &amp;lt;=&amp;gt; left = right + 1)，因为 k 不可能为负值，所以 while 的条件永远不可能成立
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>(rsum &lt;span style="color:#f92672">-&lt;/span> lsum &lt;span style="color:#f92672">&amp;gt;&lt;/span> k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lsum &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&lt;/span> nums[left&lt;span style="color:#f92672">++&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 当程序运行到这里的时候一定满足：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 1. rsum - lsum 为窗口 [l, r] 的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 2. 如果 l &amp;gt; r 那么必然有 l = r + 1 &amp;lt;=&amp;gt; rsum - lsum == 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 3. rsum - lsum &amp;lt;= k
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 综上：此时的滑动窗口必然为满足条件的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> max_window &lt;span style="color:#f92672">=&lt;/span> max(max_window, right &lt;span style="color:#f92672">-&lt;/span> left &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> max_window;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="广度优先搜索">广度优先搜索&lt;/h2>
&lt;blockquote>
&lt;p>Too Much Water!&lt;/p>
&lt;/blockquote>
&lt;p>我记得自己初中的时候学习计算机竞赛的时候，最喜欢的题目就是广度优先搜索。因为当时的我非常讨厌递归（就像我现在打麻将讨厌坎张一样），每次做递归的题目时都非常头大，并且想到经常导致的 stack overflow，相对来说更加朴素无华的广度优先算法就显得如此的和蔼可亲。&lt;/p>
&lt;p>从各种角度来讲，广度优先搜索都是非常简单的算法。它的结构简单，需要的数据结构也不复杂，优美的递归配上队列操作让它的美感油然而生。&lt;/p>
&lt;p>广度优先算法只需要一个普通的例子就可以讲清楚。我们选择“迷宫中最近的出口”来做例子。&lt;/p>
&lt;h3 id="例-1-迷宫中最近的出口">例 1：迷宫中最近的出口&lt;/h3>
&lt;p>&lt;a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/solutions/869920/mi-gong-zhong-chi-ru-kou-zui-jin-de-chu-0ued5/?envType=study-plan-v2&amp;amp;envId=leetcode-75">https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/solutions/869920/mi-gong-zhong-chi-ru-kou-zui-jin-de-chu-0ued5/?envType=study-plan-v2&amp;amp;envId=leetcode-75&lt;/a>&lt;/p>
&lt;p>这道题目是广搜的基础题。从这里可以看到广搜的若干要素。相关的介绍已经写到注释里了。不过有一个值得思考的点：为什么我们只需要遍历一次就可以知道距离最近的出口的距离呢？&lt;/p>
&lt;p>这就涉及到广度优先算法的一个重要的特性：它永远会先遍历 &lt;code>step ==== 1&lt;/code> 的节点，然后再去遍历所有 &lt;code>step == 2&lt;/code> 的节点。只要不走回头路，那么距离起点较近的路径已经可以优先被遍历到，因为不存在绕路并且让路径距离减少的方法（如果有的话使用广搜就是不行的）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n, m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ex, ey; &lt;span style="color:#75715e">// entrance 的坐标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">is_in_maze&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&lt;/span> n &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y &lt;span style="color:#f92672">&amp;lt;&lt;/span> m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">is_boundary&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>(x &lt;span style="color:#f92672">==&lt;/span> ex &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y &lt;span style="color:#f92672">==&lt;/span> ey) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> x &lt;span style="color:#f92672">==&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> y &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> y &lt;span style="color:#f92672">==&lt;/span> m &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Cord&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x, y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> step &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cord(&lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span> step &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>x &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>y &lt;span style="color:#f92672">=&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>step &lt;span style="color:#f92672">=&lt;/span> step;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> nearestExit(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> maze, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> entrance) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从自己的格子往外走，每走一步就标记下一个格子的数字是当前格子 + 1 或者上面的最小值（除了 -1 以外）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 如果走到的格子是边界，那么就和 res 比大小
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> maze.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m &lt;span style="color:#f92672">=&lt;/span> maze[&lt;span style="color:#ae81ff">0&lt;/span>].size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ex &lt;span style="color:#f92672">=&lt;/span> entrance[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ey &lt;span style="color:#f92672">=&lt;/span> entrance[&lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> dX[&lt;span style="color:#ae81ff">4&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>}; &lt;span style="color:#75715e">// 在走格子的时候，这两个数组非常有用。它们代表横纵坐标的变化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> dY[&lt;span style="color:#ae81ff">4&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Cord&lt;span style="color:#f92672">&amp;gt;&lt;/span> q; &lt;span style="color:#75715e">// !这个队列是广搜的核心。不能用栈，因为我们需要先进先出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> q.push(Cord(ex, ey, &lt;span style="color:#ae81ff">0&lt;/span>)); &lt;span style="color:#75715e">// 第一个 push 是必要的，你需要把起点放进去
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> maze[ex][ey] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>; &lt;span style="color:#75715e">// 这个标记的动作会根据实现的方法有所差异，可以参考“算法核心”部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Cord curr, next; &lt;span style="color:#75715e">// 我喜欢在外面定义，这样会更快点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(q.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 获得要 visit 的节点然后 pop
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> curr &lt;span style="color:#f92672">=&lt;/span> q.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next.step &lt;span style="color:#f92672">=&lt;/span> curr.step &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(is_boundary(curr.x, curr.y)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> res &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> curr.step : min(res, curr.step);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2. 往四个方向走
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 3. 计算下一步的坐标
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> next.x &lt;span style="color:#f92672">=&lt;/span> curr.x &lt;span style="color:#f92672">+&lt;/span> dX[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next.y &lt;span style="color:#f92672">=&lt;/span> curr.y &lt;span style="color:#f92672">+&lt;/span> dY[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 4. 判断坐标能不能走
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(is_in_maze(next.x, next.y) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> maze[next.x][next.y] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 一般来说，广搜都需要在 push 这个动作完成的时候直接标记当前块不可访问
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因为这可以避免后面的重复遍历（除非有必要这么做）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> maze[next.x][next.y] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;+&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.push(next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="例2-岛屿的最大面积">例2：岛屿的最大面积&lt;/h3>
&lt;p>&lt;a href="https://leetcode.cn/problems/ZL6zAn/description/">https://leetcode.cn/problems/ZL6zAn/description/&lt;/a>&lt;/p>
&lt;p>岛屿的最大面积也是基础题目，只不过思路可能会稍微复杂一点。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>*朴素的想法就是整个地图都遍历一遍
如果遇到水就跳过（标记为 -1）
如果遇到岛就从岛的节点开始广搜，得到面积，求面积最大值即可\
*&lt;/em>
#define is_in_map(x, y) (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; m)
#define is_island(x) (x == 1)
class Solution {
const int dX[4] = {-1, 0, 1, 0};
const int dY[4] = {0, 1, 0, -1};
int n, m;
// 从给定的“岛”的节点开始广搜，返回面积，并且把岛屿填平
int maxAreaOfSingleIsland(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int x, int y) {
if(!is_island(grid[x][y])) return 0;
queue&amp;lt;tuple&amp;lt;int, int&amp;gt;&amp;gt; q;
q.emplace(x, y);
int area = 0;
grid[x][y] = 0;
int cx, cy, nx, ny;
while(q.size()) {
auto [cx, cy] = q.front();
q.pop();
area++;
for(int i = 0;i &amp;lt; 4; ++i) {
nx = cx + dX[i];
ny = cy + dY[i];
if(is_in_map(nx, ny) &amp;amp;&amp;amp; is_island(grid[nx][ny])) {
q.emplace(nx, ny);
grid[nx][ny] = 0;
}
}
}
return area;
}
public:
int maxAreaOfIsland(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) {
n = grid.size();
m = grid[0].size();
int res = 0;
for(int i = 0;i &amp;lt; n; ++i) {
for(int j = 0;j &amp;lt; m; ++j) {
if(is_island(grid[i][j])) {
res = max(res, maxAreaOfSingleIsland(grid, i, j));
}
}
}
return res;
}
};&lt;/p>
&lt;/blockquote>
&lt;p>现在问题来了：我们有没有一种写法可以保证每个地块只被访问一次，同时得到答案的方法呢？&lt;/p>
&lt;p>我给的答案是两次广搜。一次是对水的广搜，一次是对岛的广搜。但是这会引发一个严重的问题：如果岛恰好把水分成两个部分了该怎么办？答案是在遍历水的时候，如果下一个节点是岛，那么强制让这个节点加入到队列中。这么做的理由是，因为岛的四周一定是水，那么将所有岛最外面一圈都从岛变成水，那么所有的水一定是四向联通的。就不会引起问题了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-txt" data-lang="txt">&lt;span style="display:flex;">&lt;span>之前的状态
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>111111
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>001111
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>001111
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>110000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>111111
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>111111
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>之后的状态
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>011111
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>000111
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>000111
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>000000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>110000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>111111
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*朴素的想法就是整个地图都遍历一遍
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 如果遇到水就跳过（标记为 -1）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 如果遇到岛就从岛的节点开始广搜，得到面积，求面积最大值即可\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> dX[&lt;span style="color:#ae81ff">4&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> dY[&lt;span style="color:#ae81ff">4&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n, m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">is_in_map&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&lt;/span> n &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> y &lt;span style="color:#f92672">&amp;lt;&lt;/span> m;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">is_island&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从给定的“岛”的节点开始广搜，返回面积，并且把岛屿填平
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">maxAreaOfSingleIsland&lt;/span>(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> grid, &lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>is_island(grid[x][y])) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> q;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.emplace(x, y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> area &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> grid[x][y] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cx, cy, nx, ny;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(q.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> [cx, cy] &lt;span style="color:#f92672">=&lt;/span> q.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> area&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nx &lt;span style="color:#f92672">=&lt;/span> cx &lt;span style="color:#f92672">+&lt;/span> dX[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ny &lt;span style="color:#f92672">=&lt;/span> cy &lt;span style="color:#f92672">+&lt;/span> dY[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(is_in_map(nx, ny) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> is_island(grid[nx][ny])) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.emplace(nx, ny);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> grid[nx][ny] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> area;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maxAreaOfIsland(vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> grid) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">=&lt;/span> grid.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m &lt;span style="color:#f92672">=&lt;/span> grid[&lt;span style="color:#ae81ff">0&lt;/span>].size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> q;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.emplace(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, cy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, nx, ny;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> res &lt;span style="color:#f92672">=&lt;/span> maxAreaOfSingleIsland(grid, cx, cy);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> grid[cx][cy] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(q.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> [cx, cy] &lt;span style="color:#f92672">=&lt;/span> q.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nx &lt;span style="color:#f92672">=&lt;/span> cx &lt;span style="color:#f92672">+&lt;/span> dX[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ny &lt;span style="color:#f92672">=&lt;/span> cy &lt;span style="color:#f92672">+&lt;/span> dY[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(is_in_map(nx, ny) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> grid[nx][ny] &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(is_island(grid[nx][ny])) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res &lt;span style="color:#f92672">=&lt;/span> max(res, maxAreaOfSingleIsland(grid, nx, ny));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.emplace(nx, ny);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> grid[nx][ny] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="算法核心">算法核心&lt;/h3>
&lt;p>这种和走地图有关的广搜基本上只有四个核心：&lt;/p>
&lt;ol>
&lt;li>一个队列（一定要是队列，因为你必须保证步数少的节点被优先遍历到）&lt;/li>
&lt;li>一个每次只看队头，并且往队尾塞东西的 while&lt;/li>
&lt;li>一个往四个方向走的数组&lt;/li>
&lt;li>一个判断有没有出界的函数&lt;/li>
&lt;/ol>
&lt;p>基本上写完上面的这些东西之后广搜就已经完成了。&lt;/p>
&lt;p>还有若干注意事项：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>你需要对自己应该什么时候修改当前节点的值非常清楚。如果你打算在 visit 节点的时候修改，那么就必须判断当前节点的类型。如果打算在计算 next 的时候修改，那么就需要提前对当前节点进行处理&lt;/p>
&lt;p>第一种写法是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define is_in_grid(x, y) (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; m)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define is_not_none(x, y) (grid[x][y] &amp;gt; 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">while&lt;/span>(q.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> [cx, cy] &lt;span style="color:#f92672">=&lt;/span> q.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在这里检查是否需要 visit，如果不合法直接丢弃
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这会导致最大 O(n) 的额外时间空间开销
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>(is_in_map(cx, cy) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> is_not_none(cx, cy))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nx &lt;span style="color:#f92672">=&lt;/span> cx &lt;span style="color:#f92672">+&lt;/span> dX[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ny &lt;span style="color:#f92672">=&lt;/span> cy &lt;span style="color:#f92672">+&lt;/span> dY[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.emplace(nx, ny); &lt;span style="color:#75715e">// 交给之后再处理，有一点像递归的写法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第二种写法是这样：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define is_in_grid(x, y) (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; m)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define is_not_none(x, y) (grid[x][y] &amp;gt; 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">while&lt;/span>(q.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> [cx, cy] &lt;span style="color:#f92672">=&lt;/span> q.front();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 认为数组中所有的东西都是合法的，直接 visit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nx &lt;span style="color:#f92672">=&lt;/span> cx &lt;span style="color:#f92672">+&lt;/span> dX[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ny &lt;span style="color:#f92672">=&lt;/span> cy &lt;span style="color:#f92672">+&lt;/span> dY[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(is_in_map(cx, cy) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> is_not_none(cx, cy)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q.emplace(nx, ny); &lt;span style="color:#75715e">// 保证数组中的元素一定是合法的元素
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 这种写法可能会导致额外的思考量，因为数组中的合法元素可能和想象中不同
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 就像我在例2 的写法中有一个必须添加的岛屿，否则遍历会终止
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>要明白你到底要求什么东西，需要储存每一步中的什么变量。然后把这些东西储存下来。这涉及到队列里要用什么储存&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="深度优先搜索">&lt;!-- raw HTML omitted -->TODO&lt;!-- raw HTML omitted --> 深度优先搜索&lt;/h2></description></item><item><title>Hello World!</title><link>http://localhost:1313/post/helloworld/</link><pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/helloworld/</guid><description>&lt;p>This is a hello world from hugo !&lt;/p></description></item></channel></rss>